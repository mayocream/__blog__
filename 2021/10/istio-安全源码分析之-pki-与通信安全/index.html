<!doctype html><html lang=zh-hans><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Istio 安全源码分析之 PKI 与通信安全 - Mayo's Blog</title>
<meta name=description content="这篇文章是我在公司内部探索与实践私有 CACertification Authority 与双向 TLSmutual TLS 认证体系时，学习 Istio 安全认证架构的笔记，最初于 2020.12.03 发表于团队内部，现在看来文字空洞乏力，所以我">
<meta name=author content>
<link rel=preconnect href=https://cdn.jsdelivr.net>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Press+Start+2P" rel=stylesheet>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400&family=Noto+Sans+JP:wght@300;400&family=Noto+Sans+SC:wght@300;400&family=Noto+Serif:wght@300;400&family=Noto+Serif+JP:wght@300;400&family=Noto+Serif+SC:wght@300;400&family=Source+Code+Pro:wght@300;400" rel=stylesheet>
<link rel=stylesheet href="/bundle.css?v=1635677544" media=all>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.css>
<link rel=icon href=https://github.com/mayocream.png><meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://shoujo.ink/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-JKVXF5HSKT','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="Istio 安全源码分析之 PKI 与通信安全">
<meta property="og:description" content="这篇文章是我在公司内部探索与实践私有 CACertification Authority 与双向 TLSmutual TLS 认证体系时，学习 Istio 安全认证架构的笔记，最初于 2020.12.03 发表于团队内部，现在看来文字空洞乏力，所以我">
<meta property="og:type" content="article">
<meta property="og:url" content="https://shoujo.ink/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-10-26T23:00:00+08:00">
<meta property="article:modified_time" content="2021-10-26T23:00:00+08:00"><meta property="og:site_name" content="Mayo's Blog">
</head>
</html>
<body><script src=https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>const opts={bottom:'32px',right:'unset',left:'32px',time:'0.3s',mixColor:'#fff',backgroundColor:'#fff',buttonColorDark:'#100f2c',buttonColorLight:'#fff',saveInCookies:!0,label:'🌓',autoMatchOsTheme:!0};let darkmode;window.matchMedia('only screen and (min-width: 680px)').matches?(darkmode=new Darkmode(opts),darkmode.showWidget()):(localStorage.removeItem('darkmode'),darkmode=new Darkmode(opts)),window.darkmode=darkmode,document.addEventListener('DOMContentLoaded',function(){document.body.style.opacity=1})</script>
<main class=page-content aria-label=Content>
<div class=wrapper><nav class=site-nav>
<a class=page-link href=/posts/>Posts</a>
<a class=page-link href=/about/>About</a>
</nav><header class=post-header>
<a class=site-title href=https://shoujo.ink>Mayo's Blog</a>
<h1 class="post-title baseline-fix typeface-sans" lang=zh-hans itemprop="name headline">Istio 安全源码分析之 PKI 与通信安全</h1>
</header>
<div class=post-cover aria-label=Cover>
<div class=post-cover-wrapper>
<img src alt>
</div>
<div class=cover-meta></div>
</div>
<div class=post-layout>
<article class="post typeface-sans" lang=zh-hans itemscope itemtype=http://schema.org/BlogPosting>
<div class=post-content itemprop=articleBody>
<p>这篇文章是我在公司内部探索与实践私有 <ruby>CA<rt>Certification Authority</rt></ruby> 与<ruby>双向 TLS<rt>mutual TLS</rt></ruby> 认证体系时，学习 Istio 安全认证架构的笔记，最初于 2020.12.03 发表于团队内部，现在看来文字空洞乏力，所以我对原文做了较大的调整，补充了更多内容。</p>
<p>本文基于 Istio 1.8 版本进行源码分析。</p>
<p>分析过程的代码注释在我的 Github 仓库：<a href=https://github.com/mayocream/istio/tree/citadel-review>mayocream/istio</a> citadel-review 分支。</p>
<h2 id=1-身份模型>1. 身份模型</h2>
<p>零信任架构下，需要严格区分工作负载的识别和信任，而签发 X.509 证书是推荐的一种认证方式<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。在 Kubernetes 集群中，服务间是通过 DNS 名称互相访问的，而网络流量可能被 DNS 欺骗、BGP/路由劫持、ARP 欺骗等手段劫持，为了将服务名称（DNS 名称）与服务身份强关联起来，Istio 使用置于 X.509 证书中的安全命名（Secure naming）机制<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</p>
<p>SPIFFE 是 Istio 所采用的安全命名的规范，它也是云原生定义的一种标准化的、可移植的工作负载身份规范。<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p>
<h3 id=11-介绍>1.1. 介绍</h3>
<p><a href=https://spiffe.io/>Secure Production Identity Framework For Everyone (SPIFFE)</a> 是一套服务之间相互进行身份识别的标准，主要包含以下内容：</p>
<ul>
<li>SPIFFE ID 标准，SPIFFE ID 是服务的唯一标识，具体实现使用 URI 资源标识符。</li>
<li>SPIFFE Verifiable Identity Document (SVID) 标准，将 SPIFFE ID 编码到一个加密的可验证的数据格式中。</li>
<li>颁发与撤销 SVID 的 API 标准。</li>
</ul>
<p>SPIFFE ID 规定了形如 <code>spiffe://&lt;trust domain>/&lt;workload identifier></code> 的 URI 格式，作为工作负载（Workload）的唯一标识。SVID 是 SPIFFE ID 的识别凭证，有 X.509 和 JWT 两种格式。</p>
<p>SPIFFE 规范的实现有 spiffe 官方的 <a href=https://github.com/spiffe/spire>Spire</a> 项目，而 Istio 在自身的生态中只使用到了 SPIFFE ID 作为安全命名，其数据格式由自己实现，通信格式采用 CNCF 支持的 <a href=https://github.com/cncf/xds>xDS</a> 协议规范（证书认证通信更具体来说是 xDS 的 SDS）。</p>
<p>Istio 使用形如 <code>spiffe://&lt;trust_domain>/ns/&lt;namespace>/sa/&lt;service_account></code> 格式的 SPIFFE ID 作为安全命名，注入到 X.509 证书的 subjectAltName 扩展中。其中“trust domain”参数通过 Istiod 环境变量 <code>TRUST_DOMAIN</code> 注入，用于在多集群环境中交互。</p>
<p>
<figure class=image>
<img src=/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/images/istio-security-arch-sec.svg alt="Istio 安全架构" loading=lazy>
<figcaption>Istio 安全架构</figcaption>
</figure></p>
<h3 id=12-代码实现>1.2. 代码实现</h3>
<p>SPIFFE 官方提供了 Go SDK <a href=https://github.com/spiffe/go-spiffe>go-spiffe</a>，提供一种标准的 SPIFFE 协议的客户端实现。
由于 Istio 仅仅使用了 SPIFFE ID，没有必要引入这个 SDK，还值得一提的是该 SDK 引入了 grpc 包，如果你和我一样踩过 grpc 包引用版本冲突的问题，还花费了一下午的时间来解决，这次一定要保持警惕。</p>
<p>Istio 将自己实现的 SPIFFE 相关的代码存放在 pkg 目录下的 spiffe 目录。</p>
<h4 id=数据结构>数据结构</h4>
<p>这里再提一次数据格式是形如 <code>spiffe://&lt;trust_domain>/ns/&lt;namespace>/sa/&lt;service_account></code> 的 URI 字符串。这类身份标识因系统设计不同，定义的格式也各不相同，例如蚂蚁内部使用的身份标识格式是 <code>spiffe://&lt;domain>/cluster/&lt;cluster>/&lt;required_attr_1_name>/&lt;required_attr_1_value>/&lt;required_attr_2_name>/&lt;required_attr_2_value></code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。
而敝司使用 <code>spiffe://&lt;site_id>/&lt;cluster_id>/&lt;unique_id></code> 格式，怎么样还是简洁点看起来舒服吧。</p>
<p>定义 SPIFFE 的数据结构及其解析方式。</p>
<pre><code class=language-go>type Identity struct {
    TrustDomain    string
    Namespace      string
    ServiceAccount string
}

func ParseIdentity(s string) (Identity, error) {
    if !strings.HasPrefix(s, URIPrefix) {
        return Identity{}, fmt.Errorf(&quot;identity is not a spiffe format: %v&quot;, s)
    }
    split := strings.Split(s[URIPrefixLen:], &quot;/&quot;)
    ...
    return Identity{
        TrustDomain:    split[0],
        Namespace:      split[2],
        ServiceAccount: split[4],
    }, nil
}

func (i Identity) String() string {
    return URIPrefix + i.TrustDomain + &quot;/ns/&quot; + i.Namespace + &quot;/sa/&quot; + i.ServiceAccount
}
</code></pre>
<p>信任域（Trust Domain）是由 Istiod 主程序启动时调用 <code>spiffe.SetTrustDomain(s.environment.Mesh().GetTrustDomain())</code> 函数方法设置的。</p>
<h4 id=tls-验证>TLS 验证</h4>
<p>Go 官方的 tls 包提供了 <em>VerifyPeerCertificate</em> 方法，该方法通常会在标准证书校验后（验证服务端 IP 或 DNS 名称以及证书链校验）被调用，提供额外的自定义 Peer 证书验证功能。</p>
<p>由于 SPIFFE ID 属于证书扩展内容，程序需要额外校验 SPIFFE 身份。</p>
<pre><code class=language-go>// pkg/spiffe/spiffe.go

func (v *PeerCertVerifier) VerifyPeerCert(rawCerts [][]byte, _ [][]*x509.Certificate) error {
    // 下游服务证书
    var peerCert *x509.Certificate
    // CA 证书链
    intCertPool := x509.NewCertPool()
    for id, rawCert := range rawCerts {
        cert, err := x509.ParseCertificate(rawCert)
        if id == 0 {
            // 第一个证书为 Workload 证书
            peerCert = cert
        } else {
            intCertPool.AddCert(cert)
        }
    }
    // ERROR: SAN URIs 没有 SPIFFE ID
    if len(peerCert.URIs) != 1 {
        return fmt.Errorf(&quot;peer certificate does not contain 1 URI type SAN, detected %d&quot;, len(peerCert.URIs))
    }
    trustDomain, err := GetTrustDomainFromURISAN(peerCert.URIs[0].String())
    if err != nil {
        return err
    }
    // 根证书池
    rootCertPool, ok := v.certPools[trustDomain]
    if !ok {
        return fmt.Errorf(&quot;no cert pool found for trust domain %s&quot;, trustDomain)
    }

    // 验证证书有效性
    _, err = peerCert.Verify(x509.VerifyOptions{
        Roots:         rootCertPool,
        Intermediates: intCertPool,
    })
    return err
}
</code></pre>
<p>校验过程会检查 SPIFFE ID 字段是否存在，以及 CA 证书的信任域是否与工作负载的证书处于同一有效的信任域。若校验失败，TLS 握手会以失败告终。</p>
<p>Istiod 在主程序启动时调用 <em>setPeerCertVerifier</em> 方法，设置额外的 mTLS 校验方式，以及添加 CA 证书到 Cert Pool 里：</p>
<pre><code class=language-go>// setPeerCertVerifier 设置 Istiod 的 SPIFFE 校验方式
func (s *Server) setPeerCertVerifier(tlsOptions TLSOptions) error {
    // 调用上述的 spiffe 包
    s.peerCertVerifier = spiffe.NewPeerCertVerifier()
    var rootCertBytes []byte
    var err error
    // CA 证书
    if tlsOptions.CaCertFile != &quot;&quot; {
        // 传入 CA 证书
        ...
    }

    // 加入 CA 根证书到 SPIFFIE 的信任证书里
    if len(rootCertBytes) != 0 {
        err := s.peerCertVerifier.AddMappingFromPEM(spiffe.GetTrustDomain(), rootCertBytes)
    }
    return nil
}
</code></pre>
<h4 id=外部-ca>外部 CA</h4>
<p>Istio 实现了 <a href=https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md>SPIFFE Bundle</a> 协议，该协议允许访问外部 URI 通过规定的 <a href=https://datatracker.ietf.org/doc/html/rfc7517>JWK（JSON Web Key）</a>数据格式，获取信任域对应的根证书，而无需将根证书置于程序内部。</p>
<p>Istio 定义的数据格式：</p>
<ul>
<li><em>&lt;trustdomain, endpoint></em> 元组以 || 分割</li>
<li>每个元组内使用 | 分割 trustdomain 和 endpoint</li>
<li>例如：<code>foo|https://url/for/foo||bar|https://url/for/bar</code></li>
</ul>
<p>下述方式用于获取信任域对应的 X.509 CA 证书链（可以有多层级）。该方法接收 <code>foo|URL1||bar|URL2</code> 格式的参数，用 <code>||</code> 分隔切片，第一个参数为 trust domain，第二个参数为 CA 服务器 URL。</p>
<pre><code class=language-go>// RetrieveSpiffeBundleRootCertsFromStringInput 从 SPIFFE bundle 中检索可信的 CA 证书。
// 它可以使用系统证书和提供的证书来进行验证。
// 格式如下：
// &quot;foo|URL1||bar|URL2||baz|URL3...&quot;
func RetrieveSpiffeBundleRootCertsFromStringInput(inputString string, extraTrustedCerts []*x509.Certificate) (
    map[string][]*x509.Certificate, error) {
    spiffeLog.Infof(&quot;Processing SPIFFE bundle configuration: %v&quot;, inputString)
    config := make(map[string]string)
    tuples := strings.Split(inputString, &quot;||&quot;)
    for _, tuple := range tuples {
        items := strings.Split(tuple, &quot;|&quot;)
        if len(items) != 2 {
            return nil, fmt.Errorf(&quot;config is invalid: %v. Expected &lt;trustdomain&gt;|&lt;url&gt;&quot;, tuple)
        }
        trustDomain := items[0]
        endpoint := items[1]
        config[trustDomain] = endpoint
    }
    // 调用 CA 服务器
    return RetrieveSpiffeBundleRootCerts(config, extraTrustedCerts)
}
</code></pre>
<p>外部服务器返回 JWK 格式的数据：</p>
<pre><code class=language-go>// pkg/spiffe/spiffe.go

// 返回的 JSON 结构
type bundleDoc struct {
    jose.JSONWebKeySet
    Sequence    uint64 `json:&quot;spiffe_sequence,omitempty&quot;`
    RefreshHint int    `json:&quot;spiffe_refresh_hint,omitempty&quot;`
}

// JSONWebKey represents a public or private key in JWK format.
type JSONWebKey struct {
    // Cryptographic key, can be a symmetric or asymmetric key.
    Key interface{}
    // Key identifier, parsed from `kid` header.
    KeyID string
    // Key algorithm, parsed from `alg` header.
    Algorithm string
    // Key use, parsed from `use` header.
    Use string

    // X.509 certificate chain, parsed from `x5c` header.
    Certificates []*x509.Certificate
    // X.509 certificate URL, parsed from `x5u` header.
    CertificatesURL *url.URL
    // X.509 certificate thumbprint (SHA-1), parsed from `x5t` header.
    CertificateThumbprintSHA1 []byte
    // X.509 certificate thumbprint (SHA-256), parsed from `x5t#S256` header.
    CertificateThumbprintSHA256 []byte
}
</code></pre>
<p>实际的数据示例如下。</p>
<pre><code class=language-go>{
    &quot;spiffe_sequence&quot;: 1,
    &quot;spiffe_refresh_hint&quot;: 450000,
    &quot;keys&quot;: [
        {
        &quot;kty&quot;: &quot;RSA&quot;,
        &quot;use&quot;: &quot;x509-svid&quot;,
        &quot;n&quot;: &quot;&lt;证书签名&gt;&quot;,
        &quot;e&quot;: &quot;AQAB&quot;,
        &quot;x5c&quot;: [&quot;&lt;X.509 证书&gt;&quot;]
        }
    ]
}
</code></pre>
<h2 id=2-私有-pki>2. 私有 PKI</h2>
<p>Istio 内部有一套内置的 PKI 证书基础设施。零信任架构中，PKI 是零信任模型身份认证的基石，大多数零信任网络都采用 PKI 来证明身份的真实性。零信任网络颁发的证书数量可能会很多，因此非常有必要对证书进行自动化管理。<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p>
<h3 id=21-istiod-配置>2.1. Istiod 配置</h3>
<p>Istiod 默认启用内置的 CA 服务器。</p>
<pre><code class=language-go>// pilot/pkg/features/pilot.go

EnableCAServer = env.RegisterBoolVar(&quot;ENABLE_CA_SERVER&quot;, true,
        &quot;If this is set to false, will not create CA server in istiod.&quot;).Get()
</code></pre>
<p>证书签名的默认配置项：</p>
<pre><code class=language-go>// pilot/pkg/bootstrap/istio_ca.go

// 兼容挂载名为 cacerts 的 secret
// 但已经不使用

// 使用 &quot;istio-ca-secret&quot; 来创建证书
// 兼容旧版本

var (
    // 挂载名为 cacerts 的 secret 的目录，Read-only
    LocalCertDir = env.RegisterStringVar(&quot;ROOT_CA_DIR&quot;, &quot;./etc/cacerts&quot;,
        &quot;Location of a local or mounted CA root&quot;)
    
    // 默认服务证书 TTL
    workloadCertTTL = env.RegisterDurationVar(&quot;DEFAULT_WORKLOAD_CERT_TTL&quot;,
        cmd.DefaultWorkloadCertTTL,
        &quot;The default TTL of issued workload certificates. Applied when the client sets a &quot;+
            &quot;non-positive TTL in the CSR.&quot;)

    maxWorkloadCertTTL = env.RegisterDurationVar(&quot;MAX_WORKLOAD_CERT_TTL&quot;,
        cmd.DefaultMaxWorkloadCertTTL,
        &quot;The max TTL of issued workload certificates.&quot;)

    // 自签名 CA 证书 TTL
    SelfSignedCACertTTL = env.RegisterDurationVar(&quot;CITADEL_SELF_SIGNED_CA_CERT_TTL&quot;,
        cmd.DefaultSelfSignedCACertTTL,
        &quot;The TTL of self-signed CA root certificate.&quot;)
</code></pre>
<p>Istio 主程序会挂载两个 Secert，一个是 <em>cacerts</em> Secret，用于指定 Istio 启动时用户定义的 CA 证书，另一个是 <em>istio-ca-secret</em> Secret，用于储存 Istio Pilot Discovery 程序自签名的 CA 证书及其私钥。</p>
<pre><code class=language-go>    // CA 证书不应该在 Workload 证书失效之前就失效
    // 所以此处设置证书的生命周期为证书链中的最短的时效期
    defaultCertTTL, err := ca.minTTL(opts.DefaultCertTTL)
    if err != nil {
        return ca, fmt.Errorf(&quot;failed to get default cert TTL %s&quot;, err.Error())
    }
    ca.defaultCertTTL = defaultCertTTL
</code></pre>
<p>CA 证书不应该在 Workload 证书失效之前就失效，所以此处设置 Workload 证书的生命周期为 CA 证书链中的最短的时效期。</p>
<p>Istio CA 实际挂载的 <em>istio-ca-secret</em> Secret 数据示例：</p>
<pre><code class=language-yaml>kind: Secret
apiVersion: v1
metadata:
  name: istio-ca-secret
  namespace: istio-system
data:
  ca-cert.pem: &gt;-
LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMvRENDQWVTZ0F3SUJBZ0lRQWVMc3E2ZDVFN0ZheVY2U...
  ca-key.pem: &gt;-LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBd2JpOWtucHVPS1d6SUxkM...
  cert-chain.pem: ''
  key.pem: ''
  root-cert.pem: ''
type: istio.io/ca-root

</code></pre>
<h3 id=22-初始化>2.2. 初始化</h3>
<h4 id=221-入口流程>2.2.1. 入口流程</h4>
<pre><code class=language-go>// pilot/pkg/bootstrap/server.go

// maybeCreateCA creates and initializes CA Key if needed.
func (s *Server) maybeCreateCA(caOpts *caOptions) error {
    // 默认启用
    if s.EnableCA() {
        log.Info(&quot;creating CA and initializing public key&quot;)
        var err error
        var corev1 v1.CoreV1Interface
        if s.kubeClient != nil {
            corev1 = s.kubeClient.CoreV1()
        }
        // 从远程 K8S 集群获取证书，默认不启用
        if useRemoteCerts.Get() {
            if err = s.loadRemoteCACerts(caOpts, LocalCertDir.Get()); err != nil {
                return fmt.Errorf(&quot;failed to load remote CA certs: %v&quot;, err)
            }
        }

        // TODO: Issue #27606 If External CA is configured, use that to sign DNS Certs as well. IstioCA need not be initialized
        if s.CA, err = s.createIstioCA(corev1, caOpts); err != nil {
            return fmt.Errorf(&quot;failed to create CA: %v&quot;, err)
        }
        if err = s.initPublicKey(); err != nil {
            return fmt.Errorf(&quot;error initializing public key: %v&quot;, err)
        }
    }
    return nil
}
</code></pre>
<p><code>s.createIstioCA</code> 里面详细进行 CA 初始化的操作。</p>
<pre><code class=language-go>// pilot/pkg/bootstrap/istio_ca.go

// createIstioCA initializes the Istio CA signing functionality.
func (s *Server) createIstioCA(client corev1.CoreV1Interface, opts *caOptions) (*ca.IstioCA, error) {
    var caOpts *ca.IstioCAOptions
    var err error

    // In pods, this is the optional 'cacerts' Secret.
    // TODO: also check for key.pem ( for interop )
    signingKeyFile := path.Join(LocalCertDir.Get(), &quot;ca-key.pem&quot;)

    // If not found, will default to ca-cert.pem. May contain multiple roots.
    rootCertFile := path.Join(LocalCertDir.Get(), &quot;root-cert.pem&quot;)
    if _, err := os.Stat(rootCertFile); err != nil {
        // 兼容 Istio 获取 Root cert 证书
        // In Citadel, normal self-signed doesn't use a root-cert.pem file for additional roots.
        // In Istiod, it is possible to provide one via &quot;cacerts&quot; secret in both cases, for consistency.
        rootCertFile = &quot;&quot;
    }
    if _, err := os.Stat(signingKeyFile); err != nil &amp;&amp; client != nil {
        // 在 K8S 集群中创建自签名证书
        // The user-provided certs are missing - create a self-signed cert.
        log.Info(&quot;Use self-signed certificate as the CA certificate&quot;)
        // Abort after 20 minutes.
        ctx, cancel := context.WithTimeout(context.Background(), time.Minute*20)
        defer cancel()
        // 获取证书操作符
        // rootCertFile will be added to &quot;ca-cert.pem&quot;.
        // readSigningCertOnly set to false - it doesn't seem to be used in Citadel, nor do we have a way
        // to set it only for one job.
        caOpts, err = ca.NewSelfSignedIstioCAOptions(ctx,
            selfSignedRootCertGracePeriodPercentile.Get(), SelfSignedCACertTTL.Get(),
            selfSignedRootCertCheckInterval.Get(), workloadCertTTL.Get(),
            maxWorkloadCertTTL.Get(), opts.TrustDomain, true,
            opts.Namespace, -1, client, rootCertFile,
            enableJitterForRootCertRotator.Get(), caRSAKeySize.Get())
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to create a self-signed istiod CA: %v&quot;, err)
        }
    } else {
        ...
    }
    istioCA, err := ca.NewIstioCA(caOpts)
    if err != nil {
        return nil, fmt.Errorf(&quot;failed to create an istiod CA: %v&quot;, err)
    }
    istioCA.Run(rootCertRotatorChan)
    return istioCA, nil
}
</code></pre>
<p>数据操作流程：</p>
<ol>
<li>
<p>首先读取 Kubernetes 中“cacerts”的 secret 挂载的本地目录。</p>
</li>
<li>
<p>若不存在则通过 go-client 获取 K8S 中 &ldquo;istio-ca-cert&rdquo; 的 secret，该 secret 包含 CA 的私钥及证书。</p>
</li>
<li>
<p>K8s 中没有 CA 证书，则开始自签名证书流程。</p>
</li>
</ol>
<h4 id=222-自签名-ca-证书>2.2.2. 自签名 CA 证书</h4>
<p>签发与获取证书相关参数配置对照表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>DefaultSelfSignedCACertTTL</td>
<td>3650 * 24 * time.Hour</td>
<td>自签名 Root 证书默认的 TTL</td>
</tr>
<tr>
<td>DefaultSelfSignedRootCertCheckInterval</td>
<td>1 * time.Hour</td>
<td>自签名证书定期检查证书有效期或进行证书轮换检查的默认间隔时间</td>
</tr>
<tr>
<td>DefaultRootCertGracePeriodPercentile</td>
<td>20</td>
<td>根证书平滑轮换证书的有效时长百分比，相对于证书的有效周期（TTL）</td>
</tr>
<tr>
<td>ReadSigningCertRetryInterval</td>
<td>time.Second * 5</td>
<td>读取证书与私钥失败的重试间隔时间</td>
</tr>
<tr>
<td>ReadSigningCertRetryMax</td>
<td>time.Second * 30</td>
<td>读取证书与私钥失败的最大重试次数</td>
</tr>
<tr>
<td>DefaultMaxWorkloadCertTTL</td>
<td>90 * 24 * time.Hour</td>
<td>签发工作负载证书的默认最长的 TTL</td>
</tr>
<tr>
<td>DefaultWorkloadCertTTL</td>
<td>24 * time.Hour</td>
<td>签发工作负载证书的默认的 TTL</td>
</tr>
</tbody>
</table>
<p>Istio 是具体是如何使用 Go 官方包自签名一个 CA 证书的？
主要流程为：</p>
<ol>
<li>创建 RSA 私钥（Istio 还不支持 ECDSA 私钥）</li>
<li>构建 CSR（Certificate signing request）模板</li>
<li>填充 SPIFFE ID 到 CSR 的扩展字段（ASN.1）</li>
<li>自签名 CSR 生成证书</li>
<li>创建 Kubernetes Secret 资源储存 CA 证书和私钥</li>
</ol>
<pre><code class=language-go>// security/pkg/pki/ca/ca.go

// K8S 集群内自签名证书
func NewSelfSignedIstioCAOptions(ctx context.Context,
    rootCertGracePeriodPercentile int, caCertTTL, rootCertCheckInverval, defaultCertTTL,
    maxCertTTL time.Duration, org string, dualUse bool, namespace string,
    readCertRetryInterval time.Duration, client corev1.CoreV1Interface,
    rootCertFile string, enableJitter bool, caRSAKeySize int) (caOpts *IstioCAOptions, err error) {
    // 如果证书不存在则创建证书
    // 后续读取 secret 获取
    // 获取 K8S istio-ca-secret secret 资源
    caSecret, scrtErr := client.Secrets(namespace).Get(context.TODO(), CASecret, metav1.GetOptions{})
    // 获取 secret 失败，尝试多次重新获取
    // 若超时仍然获取不到，则创建自签名证书
    if scrtErr != nil &amp;&amp; readCertRetryInterval &gt; time.Duration(0) {
        pkiCaLog.Infof(&quot;Citadel in signing key/cert read only mode. Wait until secret %s:%s can be loaded...&quot;, namespace, CASecret)
        ticker := time.NewTicker(readCertRetryInterval)
        for scrtErr != nil {
            select {
            case &lt;-ticker.C:
                if caSecret, scrtErr = client.Secrets(namespace).Get(context.TODO(), CASecret, metav1.GetOptions{}); scrtErr == nil {
                    pkiCaLog.Infof(&quot;Citadel successfully loaded the secret.&quot;)
                }
            }
        }
    }

    caOpts = &amp;IstioCAOptions{
        CAType:         selfSignedCA, // 1 自签名证书 2 用户自定义证书
        DefaultCertTTL: defaultCertTTL,
        MaxCertTTL:     maxCertTTL,
        // CA 轮转检查
        RotatorConfig: &amp;SelfSignedCARootCertRotatorConfig{
            CheckInterval:      rootCertCheckInverval,
            caCertTTL:          caCertTTL,
            retryInterval:      cmd.ReadSigningCertRetryInterval, // 默认 5 秒
            retryMax:           cmd.ReadSigningCertRetryMax, // 默认 30 秒
            certInspector:      certutil.NewCertUtil(rootCertGracePeriodPercentile),
            caStorageNamespace: namespace,
            dualUse:            dualUse, // 默认 true
            org:                org,
            rootCertFile:       rootCertFile,
            enableJitter:       enableJitter,
            client:             client,
        },
    }
    // 获取不到 secret，自签名创建
    if scrtErr != nil {
        pkiCaLog.Infof(&quot;Failed to get secret (error: %s), will create one&quot;, scrtErr)

        options := util.CertOptions{
            TTL:          caCertTTL,
            Org:          org,
            IsCA:         true, // 证书标识为 CA
            IsSelfSigned: true,
            RSAKeySize:   caRSAKeySize,
            // Whether this certificate is for dual-use clients (SAN+CN).
            IsDualUse:    dualUse, // 这个选项其实没有用到
        }
        pemCert, pemKey, ckErr := util.GenCertKeyFromOptions(options)
        if ckErr != nil {
            return nil, fmt.Errorf(&quot;unable to generate CA cert and key for self-signed CA (%v)&quot;, ckErr)
        }

        // 获取 RootCertFile 加入根证书链
        rootCerts, err := util.AppendRootCerts(pemCert, rootCertFile)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to append root certificates (%v)&quot;, err)
        }

        // 构建储存证书链的并发安全的数据结构体
        if caOpts.KeyCertBundle, err = util.NewVerifiedKeyCertBundleFromPem(pemCert, pemKey, nil, rootCerts); err != nil {
            return nil, fmt.Errorf(&quot;failed to create CA KeyCertBundle (%v)&quot;, err)
        }

        // 在 K8S 中创建 secret 储存证书
        // Write the key/cert back to secret so they will be persistent when CA restarts.
        secret := k8ssecret.BuildSecret(&quot;&quot;, CASecret, namespace, nil, nil, nil, pemCert, pemKey, istioCASecretType)
        if _, err = client.Secrets(namespace).Create(context.TODO(), secret, metav1.CreateOptions{}); err != nil {
            ...
        }
    } else {
        ...
        // 从本地读取 CA 证书
    }
    // 返回证书操作符
    return caOpts, nil
}
</code></pre>
<p>默认使用 RSA 2048 size 生成私钥：</p>
<pre><code class=language-go>// security/pkg/pki/util/generate_cert.go

// GenCertKeyFromOptions generates a X.509 certificate and a private key with the given options.
func GenCertKeyFromOptions(options CertOptions) (pemCert []byte, pemKey []byte, err error) {
    // 默认忽略，使用 RSA 算法
    if options.ECSigAlg != &quot;&quot; {
        ...
    }

    // 生成 RSA 密钥
    rsaPriv, err := rsa.GenerateKey(rand.Reader, options.RSAKeySize)
    // 生成证书
    return genCert(options, rsaPriv, &amp;rsaPriv.PublicKey)
}
</code></pre>
<p>创建一个证书模板，随后会从模板创建 CSR：</p>
<pre><code class=language-go>// security/pkg/pki/util/generate_cert.go

// genCertTemplateFromoptions generates a certificate template with the given options.
func genCertTemplateFromOptions(options CertOptions) (*x509.Certificate, error) {
    var keyUsage x509.KeyUsage
    if options.IsCA {
        // If the cert is a CA cert, the private key is allowed to sign other certificates.
        keyUsage = x509.KeyUsageCertSign
    } else {
        // Otherwise the private key is allowed for digital signature and key encipherment.
        keyUsage = x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment
    }

    subject := pkix.Name{
        Organization: []string{options.Org},
    }

    // 填充扩展字段
    exts := []pkix.Extension{}
    if h := options.Host; len(h) &gt; 0 {
        // 生成 SAN
        s, err := BuildSubjectAltNameExtension(h)
        if err != nil {
            return nil, err
        }
        if options.IsDualUse {
            // 获取 common name
            cn, err := DualUseCommonName(h)
            if err != nil {
                ...
            } else {
                subject.CommonName = cn
            }
        }
        exts = []pkix.Extension{*s}
    }

    return &amp;x509.Certificate{
        SerialNumber:          serialNum,
        Subject:               subject,
        NotBefore:             notBefore,
        NotAfter:              notBefore.Add(options.TTL),
        KeyUsage:              keyUsage,
        ExtKeyUsage:           extKeyUsages,
        IsCA:                  options.IsCA,
        BasicConstraintsValid: true,
        ExtraExtensions:       exts}, nil
}
</code></pre>
<p>注入 SPIFFE 工作负载身份标识：</p>
<pre><code class=language-go>// security/pkg/pki/util/san.go

// BuildSubjectAltNameExtension builds the SAN extension for the certificate.
func BuildSubjectAltNameExtension(hosts string) (*pkix.Extension, error) {
    ids := []Identity{}
    for _, host := range strings.Split(hosts, &quot;,&quot;) {
        if ip := net.ParseIP(host); ip != nil {
            // Use the 4-byte representation of the IP address when possible.
            if eip := ip.To4(); eip != nil {
                ip = eip
            }
            ids = append(ids, Identity{Type: TypeIP, Value: ip})
        } else if strings.HasPrefix(host, spiffe.URIPrefix) {
            ids = append(ids, Identity{Type: TypeURI, Value: []byte(host)})
        } else {
            ids = append(ids, Identity{Type: TypeDNS, Value: []byte(host)})
        }
    }

    san, err := BuildSANExtension(ids)
    if err != nil {
        return nil, fmt.Errorf(&quot;SAN extension building failure (%v)&quot;, err)
    }

    return san, nil
}

// BuildSANExtension builds a `pkix.Extension` of type &quot;Subject
// Alternative Name&quot; based on the given identities.
func BuildSANExtension(identites []Identity) (*pkix.Extension, error) {
    ...
    // 如果 subject 的信息仅存在于 subjectAltName 扩展中(仅于Email地址或URI相关)
    // 则 subject name 必须为非空结构且 subjectAltName 扩展必须为 critical。
    // SAN is Critical because the subject is empty. This is compliant with X.509 and SPIFFE standards.
    return &amp;pkix.Extension{Id: oidSubjectAlternativeName, Critical: true, Value: bs}, nil
}
</code></pre>
<p>SPIFFE ID 储存在 X.509 证书的 SAN URI 字段中。</p>
<h4 id=223-储存证书>2.2.3. 储存证书</h4>
<p>Istiod 的 CA 证书同时也会储存到本地一份。</p>
<pre><code class=language-go>// Save the root public key file and initialize the path the the file, to be used by other components.
func (s *Server) initPublicKey() error {
    // Setup the root cert chain and caBundlePath - before calling initDNSListener.
    if features.PilotCertProvider.Get() == IstiodCAProvider {
        signingKeyFile := path.Join(LocalCertDir.Get(), &quot;ca-key.pem&quot;)
        if _, err := os.Stat(signingKeyFile); err != nil {
            // When Citadel is configured to use self-signed certs, keep a local copy so other
            // components can load it via file (e.g. webhook config controller).
            if err := os.MkdirAll(dnsCertDir, 0700); err != nil {
                return err
            }
            // We have direct access to the self-signed
            internalSelfSignedRootPath := path.Join(dnsCertDir, &quot;self-signed-root.pem&quot;)

            rootCert := s.CA.GetCAKeyCertBundle().GetRootCertPem()
            if err = ioutil.WriteFile(internalSelfSignedRootPath, rootCert, 0600); err != nil {
                return err
            }
            ...
            s.caBundlePath = internalSelfSignedRootPath
        }
    }
    return nil
}
</code></pre>
<p>储存到本地目的是为了让各个独立的组件（虽然合并到 Istiod 程序中）都读取到 CA 证书。
同时还会监听文件系统的变化，及时替换证书。</p>
<pre><code class=language-go>// initCertificateWatches sets up  watches for the certs.
func (s *Server) initCertificateWatches(tlsOptions TLSOptions) error {
    // load the cert/key and setup a persistent watch for updates.
    ...
}
</code></pre>
<h3 id=23-ca-证书轮换>2.3. CA 证书轮换</h3>
<p>CA 证书轮换的代码位于 <code>security/pkg/pki/ca/selfsignedcarootcertrotator.go</code> 文件中。</p>
<p>该模块定期检查 CA 证书有效性，比对 Kubernetes 的 Secret 资源中的 CA 证书与内存中储存的 CA 证书是否一致。
若证书即将过期，则使用私钥重新签名，以颁发新的可用的 CA 证书。</p>
<pre><code class=language-go>// NewSelfSignedCARootCertRotator returns a new root cert rotator instance that
// rotates self-signed root cert periodically.
func NewSelfSignedCARootCertRotator(config *SelfSignedCARootCertRotatorConfig,
    ca *IstioCA) *SelfSignedCARootCertRotator {
    rotator := &amp;SelfSignedCARootCertRotator{
        caSecretController: controller.NewCaSecretController(config.client),
        config:             config,
        ca:                 ca,
    }
    ...
    return rotator
}
</code></pre>
<p>该证书轮换器带有指数退避算法，以更优雅地定期错误重试。</p>
<pre><code class=language-go>// Run refreshes root certs and updates config map accordingly.
func (rotator *SelfSignedCARootCertRotator) Run(stopCh chan struct{}) {
    ...
    ticker := time.NewTicker(rotator.config.CheckInterval)
    for {
        select {
        case &lt;-ticker.C:
            rootCertRotatorLog.Info(&quot;Check and rotate root cert.&quot;)
            rotator.checkAndRotateRootCert()
        }
    }
}
</code></pre>
<p><code>checkAndRotateRootCert</code> 函数定时被执行，以确认证书的有效性指标。
<em>Citadel</em> 是 Istio 中专门负责认证相关的组件，虽然合并到 Istiod 中，
在代码中它还是被单独归类。</p>
<pre><code class=language-go>// checkAndRotateRootCert decides whether root cert should be refreshed, and rotates
// root cert for self-signed Citadel.
func (rotator *SelfSignedCARootCertRotator) checkAndRotateRootCert() {
    // 带失败重试获取 CA 证书的 K8s secret
    caSecret, scrtErr := rotator.caSecretController.LoadCASecretWithRetry(CASecret,
        rotator.config.caStorageNamespace, rotator.config.retryInterval, rotator.config.retryMax)

    if scrtErr != nil {
        ...
    } else {
        rotator.checkAndRotateRootCertForSigningCertCitadel(caSecret)
    }
}

// checkAndRotateRootCertForSigningCertCitadel checks root cert secret and rotates
// root cert if the current one is about to expire. The rotation uses existing
// root private key to generate a new root cert, and updates root cert secret.
func (rotator *SelfSignedCARootCertRotator) checkAndRotateRootCertForSigningCertCitadel(
    caSecret *v1.Secret) {
    // Check root certificate expiration time in CA secret
    waitTime, err := rotator.config.certInspector.GetWaitTime(caSecret.Data[caCertID], time.Now(), time.Duration(0))
    if err == nil &amp;&amp; waitTime &gt; 0 {
        rootCertRotatorLog.Info(&quot;Root cert is not about to expire, skipping root cert rotation.&quot;)
        caCertInMem, _, _, _ := rotator.ca.GetCAKeyCertBundle().GetAllPem()
        // 比较内存中的证书与 K8S 中的证书是否一致
        // If CA certificate is different from the CA certificate in local key
        // cert bundle, it implies that other Citadels have updated istio-ca-secret.
        // Reload root certificate into key cert bundle.
        if !bytes.Equal(caCertInMem, caSecret.Data[caCertID]) {
            // 校验证书并将证书加载到内存中缓存
            if err := rotator.ca.GetCAKeyCertBundle().VerifyAndSetAll(caSecret.Data[caCertID],
                caSecret.Data[caPrivateKeyID], nil, rootCerts); err != nil {
                rootCertRotatorLog.Errorf(&quot;failed to reload root cert into KeyCertBundle (%v)&quot;, err)
            } else {
                rootCertRotatorLog.Info(&quot;Successfully reloaded root cert into KeyCertBundle.&quot;)
            }
        }
        return
    }

    rootCertRotatorLog.Infof(&quot;Refresh root certificate, root cert is about to expire: %s&quot;, err.Error())


    options := util.CertOptions{
        TTL:           rotator.config.caCertTTL,
        SignerPrivPem: caSecret.Data[caPrivateKeyID],
        Org:           rotator.config.org,
        IsCA:          true,
        IsSelfSigned:  true,
        RSAKeySize:    rotator.ca.caRSAKeySize,
        IsDualUse:     rotator.config.dualUse,
    }
    // options should be consistent with the one used in NewSelfSignedIstioCAOptions().
    // This is to make sure when rotate the root cert, we don't make unnecessary changes
    // to the certificate or add extra fields to the certificate.
    options = util.MergeCertOptions(options, oldCertOptions)
    // 重新签发证书
    pemCert, pemKey, ckErr := util.GenRootCertFromExistingKey(options)
    if ckErr != nil {
        rootCertRotatorLog.Errorf(&quot;unable to generate CA cert and key for self-signed CA: %s&quot;, ckErr.Error())
        return
    }

    ...
    // 在 K8S 及内存中更新证书
    if rollback, err := rotator.updateRootCertificate(caSecret, true, pemCert, pemKey, pemRootCerts); err != nil {
        ...
        // caSecret is out-of-date. Need to load the latest istio-ca-secret to roll back root certificate.
        _, err = rotator.updateRootCertificate(nil, false, oldCaCert, oldCaPrivateKey, oldRootCerts)
        if err != nil {
            rootCertRotatorLog.Errorf(&quot;Failed to roll backward root certificate (error: %s).&quot;, err.Error())
        }
        return
    }
    rootCertRotatorLog.Info(&quot;Root certificate rotation is completed successfully.&quot;)
}
</code></pre>
<p>同时证书更新替换时也有失败回滚机制，CA 证书轮换后 Istio 会更新 Kubernetes 中 Secret 资源，以及内存中缓存的证书资源。
这类证书轮换函数，运行在独立的协程中。</p>
<pre><code class=language-go>func (ca *IstioCA) Run(stopChan chan struct{}) {
    if ca.rootCertRotator != nil {
        // Start root cert rotator in a separate goroutine.
        go ca.rootCertRotator.Run(stopChan)
    }
}
</code></pre>
<h3 id=24-签发-workload-证书>2.4. 签发 Workload 证书</h3>
<p>以上部分是 Istio 如何签发 CA 与轮换 CA 证书，因为证书都是在同一个进程中签发与替换，不涉及额外的网络操作，
相对流程比较清晰。Workload 证书签发是由独立运行的工作负载的 Pod 中的 Agent 进程向 Kubernetes 进行认证后，
发送 CSR 请求给 Istio CA 服务器进行签名的。它还拥有一套特殊的通信协议。</p>
<h4 id=241-启动-ca-服务器>2.4.1. 启动 CA 服务器</h4>
<p>Istiod 启动 CA 服务器，响应工作负载签发符合自身权限身份的 CSR 请求。</p>
<pre><code class=language-go>// StartCA starts the CA or RA server if configured.
func (s *Server) startCA(caOpts *caOptions) {
   s.addStartFunc(func(stop &lt;-chan struct{}) error {
      grpcServer := s.secureGrpcServer
      if s.secureGrpcServer == nil {
         grpcServer = s.grpcServer
      }
      // Start the RA server if configured, else start the CA server
      if s.RA != nil {
        ...
      } else if s.CA != nil {
         log.Infof(&quot;Starting IstioD CA&quot;)
         s.RunCA(grpcServer, s.CA, caOpts)
      }
      return nil
   })
}
</code></pre>
<p>CA 服务器的接口注册在 grpc 服务器上，注意这里开启了 TLS，通信协议是 grpcs。</p>
<pre><code class=language-go>// 在 GRPCS 服务器上开启 CA
// RunCA will start the cert signing GRPC service on an existing server.
// Protected by installer options: the CA will be started only if the JWT token in /var/run/secrets
// is mounted. If it is missing - for example old versions of K8S that don't support such tokens -
// we will not start the cert-signing server, since pods will have no way to authenticate.
func (s *Server) RunCA(grpc *grpc.Server, ca caserver.CertificateAuthority, opts *caOptions) {
    iss := trustedIssuer.Get() // 默认为空
    aud := audience.Get() // 默认为空

    // 填充 iss 和 aud
    // 默认获取 K8S SA Token
    // &quot;/var/run/secrets/kubernetes.io/serviceaccount/token&quot;
    token, err := ioutil.ReadFile(s.jwtPath)
    if err == nil {
        // 获取 JWT Payload
        tok, err := detectAuthEnv(string(token))
        if err != nil {
            log.Warn(&quot;Starting with invalid K8S JWT token&quot;, err, string(token))
        } else {
            if iss == &quot;&quot; {
                iss = tok.Iss
            }
            if len(tok.Aud) &gt; 0 &amp;&amp; len(aud) == 0 {
                aud = tok.Aud[0]
            }
        }
    }

    // The CA API uses cert with the max workload cert TTL.
    // 'hostlist' must be non-empty - but is not used since a grpc server is passed.
    // Adds client cert auth and kube (sds enabled)
    // 创建给 Workload 颁发证书的 CA
    caServer, startErr := caserver.New(ca, maxWorkloadCertTTL.Get(), opts.Authenticators)
    if startErr != nil {
        log.Fatalf(&quot;failed to create istio ca server: %v&quot;, startErr)
    }

    // 注册 GRPC PB
    caServer.Register(grpc)

    log.Info(&quot;Istiod CA has started&quot;)
}
</code></pre>
<p>Kubernetes Serivce Account Token 包含的 Payload 数据示例：</p>
<pre><code class=language-json>{
  &quot;iss&quot;: &quot;kubernetes/serviceaccount&quot;,
  &quot;kubernetes.io/serviceaccount/namespace&quot;: &quot;istio-system&quot;,
  &quot;kubernetes.io/serviceaccount/secret.name&quot;: &quot;istio-reader-service-account-token-zmks5&quot;,
  &quot;kubernetes.io/serviceaccount/service-account.name&quot;: &quot;istio-reader-service-account&quot;,
  &quot;kubernetes.io/serviceaccount/service-account.uid&quot;: &quot;9a544d83-ed88-474f-967c-27473357ee95&quot;,
  &quot;sub&quot;: &quot;system:serviceaccount:istio-system:istio-reader-service-account&quot;
}
</code></pre>
<p>默认配置中，签发给 Workload 的证书的有效期是 90 天。</p>
<pre><code class=language-go>// security/pkg/server/ca/server.go
// Register registers a GRPC server on the specified port.
func (s *Server) Register(grpcServer *grpc.Server) {
    pb.RegisterIstioCertificateServiceServer(grpcServer, s)
}

// istio.io\api@v0.0.0-20201125194658-3cee6a1d3ab4\security\v1alpha1\ca.pb.go
// IstioCertificateServiceServer is the server API for IstioCertificateService service.
type IstioCertificateServiceServer interface {
    // Using provided CSR, returns a signed certificate.
    CreateCertificate(context.Context, *IstioCertificateRequest) (*IstioCertificateResponse, error)
}
</code></pre>
<p>CA 服务器的 grpc 接口只有一个 <code>CreateCertificate</code> 方法，调用该方法处理 CSR 请求。</p>
<h4 id=242-签发证书>2.4.2. 签发证书</h4>
<p>通过 grpcs 协议接收到 CSR 请求时，首先会进行认证：</p>
<p>Istio 支持多种方式进行认证，例如客户端证书、K8s JWT、ID Token 等，Istio 认证方法中会尝试从多个认证源进行认证，
选择出能够验证客户端身份的一种方式，当然认证失败就失败了。</p>
<pre><code class=language-go>// authenticate goes through a list of authenticators (provided client cert, k8s jwt, and ID token)
// and authenticates if one of them is valid.
func (s *Server) authenticate(ctx context.Context) *authenticate.Caller {
    // TODO: apply different authenticators in specific order / according to configuration.
    var errMsg string
    for id, authn := range s.Authenticators {
        u, err := authn.Authenticate(ctx)
        ...
    }
    serverCaLog.Warnf(&quot;Authentication failed for %v: %s&quot;, getConnectionAddress(ctx), errMsg)
    return nil
}
</code></pre>
<p>具体处理 CSR 创建证书的接口逻辑：</p>
<pre><code class=language-go>// CreateCertificate handles an incoming certificate signing request (CSR). It does
// authentication and authorization. Upon validated, signs a certificate that:
// the SAN is the identity of the caller in authentication result.
// the subject public key is the public key in the CSR.
// the validity duration is the ValidityDuration in request, or default value if the given duration is invalid.
// it is signed by the CA signing key.
func (s *Server) CreateCertificate(ctx context.Context, request *pb.IstioCertificateRequest) (
    *pb.IstioCertificateResponse, error) {
    // metrics
    s.monitoring.CSR.Increment()
    // 从 GRPC CTX 获取 TLS Info 里面的 SPIFFE ID
    caller := s.authenticate(ctx)
    if caller == nil {
        // 缺少 TLS Info 的客户端证书的 SAN URI 字段
        s.monitoring.AuthnError.Increment()
        return nil, status.Error(codes.Unauthenticated, &quot;request authenticate failure&quot;)
    }

    // TODO: Call authorizer.

    _, _, certChainBytes, rootCertBytes := s.ca.GetCAKeyCertBundle().GetAll()
    // 签发证书
    cert, signErr := s.ca.Sign(
        []byte(request.Csr), caller.Identities, time.Duration(request.ValidityDuration)*time.Second, false)
    
    respCertChain := []string{string(cert)}
    if len(certChainBytes) != 0 {
        // 加入证书链
        respCertChain = append(respCertChain, string(certChainBytes))
    }
    respCertChain = append(respCertChain, string(rootCertBytes))
    response := &amp;pb.IstioCertificateResponse{
        CertChain: respCertChain,
    }
    s.monitoring.Success.Increment()
    serverCaLog.Debug(&quot;CSR successfully signed.&quot;)
    return response, nil
}
</code></pre>
<h3 id=25-ra注册机构>2.5. RA（注册机构）</h3>
<blockquote>
<p>Istio 带有现成的证书颁发机构（CA），但不少用户也希望能够接入现有 CA。
在之前的版本中，您需要实现 Istio CSR API 并自行编写第三方集成。
在 Istio 1.8 中，我们引入了一种使用 Kubernetes CSR API 的新方法，此方法可与任何能够使用此API的工具相集成。
Istiod 将充当注册机构（RA）角色，负责对工作负载进行身份验证及授权，而后创建、批准并监控 CSR 资源的更新。
接下来，第三方工具（例如cert-manager）即可使用正确的签名程序创建具有适当后端 CA 的签名证书。
此功能目前尚处于试验阶段。<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p>
</blockquote>
<pre><code class=language-go>// pilot/pkg/bootstrap/server.go

func (s *Server) maybeCreateCA(caOpts *caOptions) error {
    if s.EnableCA() {
        ...
        if caOpts.ExternalCAType != &quot;&quot; {
            if s.RA, err = s.createIstioRA(s.kubeClient, caOpts); err != nil {
                return fmt.Errorf(&quot;failed to create RA: %v&quot;, err)
            }
        }
        ...
    }
}
</code></pre>
<p>如果配置了自定义 CA，则启用 RA 功能。</p>
<pre><code class=language-go>// pilot/pkg/bootstrap/istio_ca.go

// createIstioRA initializes the Istio RA signing functionality.
// the caOptions defines the external provider
func (s *Server) createIstioRA(client kubelib.Client,
   opts *caOptions) (ra.RegistrationAuthority, error) {

   caCertFile := path.Join(ra.DefaultExtCACertDir, constants.CACertNamespaceConfigMapDataName)
   if _, err := os.Stat(caCertFile); err != nil {
      caCertFile = defaultCACertPath
   }
   raOpts := &amp;ra.IstioRAOptions{
      ExternalCAType: opts.ExternalCAType,
      DefaultCertTTL: workloadCertTTL.Get(),
      MaxCertTTL:     maxWorkloadCertTTL.Get(),
      CaSigner:       opts.ExternalCASigner,
      CaCertFile:     caCertFile,
      VerifyAppendCA: true,
      K8sClient:      client.CertificatesV1beta1(),
   }
   return ra.NewIstioRA(raOpts)

}

// security/pkg/pki/ra/common.go

// NewIstioRA is a factory method that returns an RA that implements the RegistrationAuthority functionality.
// the caOptions defines the external provider
func NewIstioRA(opts *IstioRAOptions) (RegistrationAuthority, error) {
    if opts.ExternalCAType == ExtCAK8s {
        istioRA, err := NewKubernetesRA(opts)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to create an K8s CA: %v&quot;, err)
        }
        return istioRA, err
    }
    return nil, fmt.Errorf(&quot;invalid CA Name %s&quot;, opts.ExternalCAType)
}

</code></pre>
<p>看上去 RA 类型现在只支持 Kubernetes 一种。</p>
<p>RA 默认不启用，同时处于试验阶段，这里不加以分析。</p>
<h2 id=3-通信安全>3. 通信安全</h2>
<p>加密和认证通常是紧密相关的，在零信任流量安全中，
对于客户端/服务器的交互，使用双向认证的 TLS 协议是一种的合理的网络安全方案，
这种方案通常包括配置客户端并将客户端证书提供给服务器端访问代理，以确保连接经过认证和授权<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>。</p>
<h3 id=31-加密与认证>3.1. 加密与认证</h3>
<h4 id=311-tls-验证>3.1.1. TLS 验证</h4>
<p>初始化服务端的 TLS 的校验方式。</p>
<pre><code class=language-go>// pilot/pkg/bootstrap/server.go

    cfg := &amp;tls.Config{
        GetCertificate: s.getIstiodCertificate,
        ClientAuth:     tls.VerifyClientCertIfGiven,
        ClientCAs:      s.peerCertVerifier.GetGeneralCertPool(),
        VerifyPeerCertificate: func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error {
            // 使用 SPIFFE 包校验 TLS 证书有效性
            err := s.peerCertVerifier.VerifyPeerCert(rawCerts, verifiedChains)
            if err != nil {
                log.Infof(&quot;Could not verify certificate: %v&quot;, err)
            }
            return err
        },
    }
</code></pre>
<p>ClientAuth 有五种类型，各自的含义是：</p>
<ul>
<li>
<p>NoClientCert：忽略任何客户端证书，即客户端可以不提供证书。</p>
</li>
<li>
<p>RequestClientCer：要求客户端提供证书，但是如果客户端没有提供证书，服务端还是会继续处理请求。</p>
</li>
<li>
<p>RequireAnyClientCert：需要客户端提供证书，但不用ClientCA来验证证书的有效性。</p>
</li>
<li>
<p>VerifyClientCertIfGiven：如果客户端提供了证书，则用ClientCA来验证证书的有效性。 如果客户端没提供，则会继续处理请求。</p>
</li>
<li>
<p>RequireAndVerifyClientCert：需要客户端提供证书，且会用ClientCA来验证证书的有效性。</p>
</li>
</ul>
<p>在 tlsConfig 中如果不显式的指定 ClientAuth，则默认值是 NoClientCert。即使 Server 端配置了 CA，也不会校验客户端证书。</p>
<h4 id=312-身份认证>3.1.2. 身份认证</h4>
<p>配置服务端对客户端进行身份认证的方式，默认启用客户端证书，以及 K8s JWT。</p>
<pre><code class=language-go> // pilot/pkg/bootstrap/server.go
 
     // Notice that the order of authenticators matters, since at runtime
     // authenticators are activated sequentially and the first successful attempt
     // is used as the authentication result.
     // The JWT authenticator requires the multicluster registry to be initialized, so we build this later
     authenticators := []authenticate.Authenticator{
         &amp;authenticate.ClientCertAuthenticator{},
         kubeauth.NewKubeJWTAuthenticator(s.kubeClient, s.clusterID, s.multicluster.GetRemoteKubeClient, spiffe.GetTrustDomain(), features.JwtPolicy.Get()),
     }
 
     // 默认启用
     caOpts.Authenticators = authenticators
     if features.XDSAuth {
         s.XDSServer.Authenticators = authenticators
     }
</code></pre>
<p>无论是 grpcs，还是 grpc 协议都会启用强认证。</p>
<pre><code class=language-go>// security/pkg/server/ca/authenticate/model.go

// Caller carries the identity and authentication source of a caller.
type Caller struct {
    AuthSource AuthSource
    Identities []string
}

type Authenticator interface {
    Authenticate(ctx context.Context) (*Caller, error)
    AuthenticatorType() string
}

</code></pre>
<p>实现了 Authenticator 接口的认证器调用 Authenticate 方法从 grpc 请求的上下文 Metadata 字段中获取 Caller 信息，校验失败则返回错误。</p>
<h5 id=客户端证书认证>客户端证书认证</h5>
<pre><code class=language-go>// security/pkg/server/ca/authenticate/cert_authenticator.go

// ClientCertAuthenticator extracts identities from client certificate.
type ClientCertAuthenticator struct{}

var _ Authenticator = &amp;ClientCertAuthenticator{}

func (cca *ClientCertAuthenticator) AuthenticatorType() string {
    return ClientCertAuthenticatorType
}

// Authenticate extracts identities from presented client certificates. This
// method assumes that certificate chain has been properly validated before
// this method is called. In other words, this method does not do certificate
// chain validation itself.
func (cca *ClientCertAuthenticator) Authenticate(ctx context.Context) (*Caller, error) {
    // 从 GRPC 连接获取 peer 信息
    peer, ok := peer.FromContext(ctx)
    if !ok || peer.AuthInfo == nil {
        return nil, fmt.Errorf(&quot;no client certificate is presented&quot;)
    }

    // 连接必须为 TLS
    if authType := peer.AuthInfo.AuthType(); authType != &quot;tls&quot; {
        return nil, fmt.Errorf(&quot;unsupported auth type: %q&quot;, authType)
    }

    tlsInfo := peer.AuthInfo.(credentials.TLSInfo)
    chains := tlsInfo.State.VerifiedChains
    if len(chains) == 0 || len(chains[0]) == 0 {
        return nil, fmt.Errorf(&quot;no verified chain is found&quot;)
    }

    ids, err := util.ExtractIDs(chains[0][0].Extensions)
    if err != nil {
        return nil, err
    }

    return &amp;Caller{
        AuthSource: AuthSourceClientCertificate,
        Identities: ids, // id 应该就是 SPIFFE ID
    }, nil
}

</code></pre>
<p>grpc TLS 包会在 TLS 握手阶段获取 SPIFFIE ID：</p>
<pre><code class=language-go>// grpc@v1.33.1\credentials\tls.go

// TLSInfo contains the auth information for a TLS authenticated connection.
// It implements the AuthInfo interface.
type TLSInfo struct {
    State tls.ConnectionState
    CommonAuthInfo
    // This API is experimental.
    SPIFFEID *url.URL
}

func (c *tlsCreds) ServerHandshake(rawConn net.Conn) (net.Conn, AuthInfo, error) {
    conn := tls.Server(rawConn, c.config)
    if err := conn.Handshake(); err != nil {
        conn.Close()
        return nil, nil, err
    }
    tlsInfo := TLSInfo{
        State: conn.ConnectionState(),
        CommonAuthInfo: CommonAuthInfo{
            SecurityLevel: PrivacyAndIntegrity,
        },
    }
    id := credinternal.SPIFFEIDFromState(conn.ConnectionState())
    if id != nil {
        tlsInfo.SPIFFEID = id
    }
    return credinternal.WrapSyscallConn(rawConn, conn), tlsInfo, nil
}

// grpc@v1.33.1\internal\credentials\spiffe.go

// SPIFFEIDFromState parses the SPIFFE ID from State. If the SPIFFE ID format
// is invalid, return nil with warning.
func SPIFFEIDFromState(state tls.ConnectionState) *url.URL {
    if len(state.PeerCertificates) == 0 || len(state.PeerCertificates[0].URIs) == 0 {
        return nil
    }
    var spiffeID *url.URL
    for _, uri := range state.PeerCertificates[0].URIs {
        if uri == nil || uri.Scheme != &quot;spiffe&quot; || uri.Opaque != &quot;&quot; || (uri.User != nil &amp;&amp; uri.User.Username() != &quot;&quot;) {
            continue
        }
        // From this point, we assume the uri is intended for a SPIFFE ID.
        if len(uri.String()) &gt; 2048 {
            logger.Warning(&quot;invalid SPIFFE ID: total ID length larger than 2048 bytes&quot;)
            return nil
        }
        if len(uri.Host) == 0 || len(uri.RawPath) == 0 || len(uri.Path) == 0 {
            logger.Warning(&quot;invalid SPIFFE ID: domain or workload ID is empty&quot;)
            return nil
        }
        if len(uri.Host) &gt; 255 {
            logger.Warning(&quot;invalid SPIFFE ID: domain length larger than 255 characters&quot;)
            return nil
        }
        // A valid SPIFFE certificate can only have exactly one URI SAN field.
        if len(state.PeerCertificates[0].URIs) &gt; 1 {
            logger.Warning(&quot;invalid SPIFFE ID: multiple URI SANs&quot;)
            return nil
        }
        spiffeID = uri
    }
    return spiffeID
}

</code></pre>
<h5 id=k8s-jwt-认证>K8s JWT 认证</h5>
<pre><code class=language-go>// security/pkg/server/ca/authenticate/kubeauth/kube_jwt.go

// KubeJWTAuthenticator authenticates K8s JWTs.
type KubeJWTAuthenticator struct {
    trustDomain string
    jwtPolicy   string

    // Primary cluster kube client
    kubeClient kubernetes.Interface
    // Primary cluster ID
    clusterID string

    // remote cluster kubeClient getter
    remoteKubeClientGetter RemoteKubeClientGetter
}

var _ authenticate.Authenticator = &amp;KubeJWTAuthenticator{}

// Authenticate authenticates the call using the K8s JWT from the context.
// The returned Caller.Identities is in SPIFFE format.
func (a *KubeJWTAuthenticator) Authenticate(ctx context.Context) (*authenticate.Caller, error) {
    // 从 HTTP Authenticate 字段获取 JWT Token
    targetJWT, err := authenticate.ExtractBearerToken(ctx)
    clusterID := extractClusterID(ctx)
    var id []string

    kubeClient := a.GetKubeClient(clusterID)
    
    id, err = tokenreview.ValidateK8sJwt(kubeClient, targetJWT, aud)
    ...
    callerNamespace := id[0]
    callerServiceAccount := id[1]
    return &amp;authenticate.Caller{
        AuthSource: authenticate.AuthSourceIDToken,
        Identities: []string{fmt.Sprintf(authenticate.IdentityTemplate, a.trustDomain, callerNamespace, callerServiceAccount)},
    }, nil
}
</code></pre>
<p>从 grpc 通信 Metadata 中获取 JWT Token，与 K8s API Server 通信认证 Token：</p>
<pre><code class=language-go>func ValidateK8sJwt(kubeClient kubernetes.Interface, targetToken string, aud []string) ([]string, error) {
    tokenReview := &amp;k8sauth.TokenReview{
        Spec: k8sauth.TokenReviewSpec{
            Token: targetToken,
        },
    }
    reviewRes, err := kubeClient.AuthenticationV1().TokenReviews().Create(context.TODO(), tokenReview, metav1.CreateOptions{})
    ...
    return getTokenReviewResult(reviewRes)
}
</code></pre>
<p>从代码注释中可以看到请求和返回的示例数据：</p>
<pre><code class=language-go>    // An example SA token:
    // {&quot;alg&quot;:&quot;RS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}
    // {&quot;iss&quot;:&quot;kubernetes/serviceaccount&quot;,
    //  &quot;kubernetes.io/serviceaccount/namespace&quot;:&quot;default&quot;,
    //  &quot;kubernetes.io/serviceaccount/secret.name&quot;:&quot;example-pod-sa-token-h4jqx&quot;,
    //  &quot;kubernetes.io/serviceaccount/service-account.name&quot;:&quot;example-pod-sa&quot;,
    //  &quot;kubernetes.io/serviceaccount/service-account.uid&quot;:&quot;ff578a9e-65d3-11e8-aad2-42010a8a001d&quot;,
    //  &quot;sub&quot;:&quot;system:serviceaccount:default:example-pod-sa&quot;
    //  }

    // An example token review status
    // &quot;status&quot;:{
    //   &quot;authenticated&quot;:true,
    //   &quot;user&quot;:{
    //     &quot;username&quot;:&quot;system:serviceaccount:default:example-pod-sa&quot;,
    //     &quot;uid&quot;:&quot;ff578a9e-65d3-11e8-aad2-42010a8a001d&quot;,
    //     &quot;groups&quot;:[&quot;system:serviceaccounts&quot;,&quot;system:serviceaccounts:default&quot;,&quot;system:authenticated&quot;]
    //    }
    // }
</code></pre>
<h3 id=32-xds-通信协议>3.2. xDS 通信协议</h3>
<p>SDS 协议是 xDS 协议的一类，在 Istio 中，SDS 用于传输证书数据。</p>
<pre><code class=language-mermaid>graph LR
    A[Discovery] &lt;-- SDS --&gt; B[pilot-agent] &lt;-- &quot;SDS (UDS)&quot; --&gt; C[Envoy]
</code></pre>
<p><em>pilot-agent</em> 原本叫 Node Agent，负责转发 Envoy 的 SDS 请求，以及负责生成 CSR 请求到 discovery。</p>
<p>为了避免混淆，注明镜像名：</p>
<ul>
<li>pilot-agent: <code>istio/proxyv2:1.8.0</code> 中的 <code>pilot-agent proxy sidecar</code></li>
<li>discovery: <code>istio/pilot:1.8.0</code></li>
</ul>
<h4 id=321-server>3.2.1. Server</h4>
<h5 id=事件广播>事件广播</h5>
<p>Discovery 初始化 SDS 服务器：</p>
<pre><code class=language-go>// initSDSServer starts the SDS server
func (s *Server) initSDSServer(args *PilotArgs) {
    if s.kubeClient != nil {
        if !features.EnableXDSIdentityCheck {
            // Make sure we have security
            log.Warnf(&quot;skipping Kubernetes credential reader; PILOT_ENABLE_XDS_IDENTITY_CHECK must be set to true for this feature.&quot;)
        } else {
            // 启用 XDS Namespace 认证
            // 默认是 istio-system Namespace
            // 监听 K8S Secrets 变化
            sc := kubesecrets.NewMulticluster(s.kubeClient, s.clusterID, args.RegistryOptions.ClusterRegistriesNamespace)
            sc.AddEventHandler(func(name, namespace string) {
                s.XDSServer.ConfigUpdate(&amp;model.PushRequest{
                    Full: false,
                    ConfigsUpdated: map[model.ConfigKey]struct{}{
                        {
                            Kind:      gvk.Secret,
                            Name:      name,
                            Namespace: namespace,
                        }: {},
                    },
                    Reason: []model.TriggerReason{model.SecretTrigger},
                })
            })
            // XDS Generator
            s.XDSServer.Generators[v3.SecretType] = xds.NewSecretGen(sc, s.XDSServer.Cache)
        }
    }
}
</code></pre>
<p><code>SecretController</code> 会监视 K8s 集群中特殊类型（Istio 多集群）的 Secret 资源变化，并通过 xDS 广播：</p>
<pre><code class=language-go>// pkg/kube/secretcontroller/secretcontroller.go

    secretsInformer := cache.NewSharedIndexInformer(
        &amp;cache.ListWatch{
            ListFunc: func(opts meta_v1.ListOptions) (runtime.Object, error) {
                // 限定 Label 为 &quot;istio/multiCluster=true&quot;
                opts.LabelSelector = MultiClusterSecretLabel + &quot;=true&quot;
                return kubeclientset.CoreV1().Secrets(namespace).List(context.TODO(), opts)
            },
            WatchFunc: func(opts meta_v1.ListOptions) (watch.Interface, error) {
                opts.LabelSelector = MultiClusterSecretLabel + &quot;=true&quot;
                return kubeclientset.CoreV1().Secrets(namespace).Watch(context.TODO(), opts)
            },
        },
        &amp;corev1.Secret{}, 0, cache.Indexers{},
    )
</code></pre>
<h5 id=gateway-证书>Gateway 证书</h5>
<p><code>Generate</code> 方法仅仅在 pilot-agent 类型为 router（即 Gateway）的时候生成 Envoy 使用的证书返回。</p>
<pre><code class=language-go>// pilot/pkg/xds/sds.go

// 与 Node Agent 也就是 Istio Proxy 进行通信返回的方法
func (s *SecretGen) Generate(proxy *model.Proxy, _ *model.PushContext, w *model.WatchedResource, req *model.PushRequest) model.Resources {
  ...
   // 调用 K8S API Server 确认身份 SA 是否有权限访问 secrets
   if err := secrets.Authorize(proxy.VerifiedIdentity.ServiceAccount, proxy.VerifiedIdentity.Namespace); err != nil {
      adsLog.Warnf(&quot;proxy %v is not authorized to receive secrets: %v&quot;, proxy.ID, err)
      return nil
   }
   // 如果不是 gateway 则返回 nil
   if req == nil || !needsUpdate(proxy, req.ConfigsUpdated) {
      return nil
   }
   var updatedSecrets map[model.ConfigKey]struct{}
   if !req.Full {
      updatedSecrets = model.ConfigsOfKind(req.ConfigsUpdated, gvk.Secret)
   }
   results := model.Resources{}
   for _, resource := range w.ResourceNames {
      ...
      isCAOnlySecret := strings.HasSuffix(sr.Name, GatewaySdsCaSuffix)
      if isCAOnlySecret {
         secret := secrets.GetCaCert(sr.Name, sr.Namespace)
         if secret != nil {
            res := toEnvoyCaSecret(sr.ResourceName, secret)
            results = append(results, res)
            s.cache.Add(sr, res)
         } else {
            adsLog.Warnf(&quot;failed to fetch ca certificate for %v&quot;, sr.ResourceName)
         }
      } else {
          // 生成密钥和证书
         key, cert := secrets.GetKeyAndCert(sr.Name, sr.Namespace)
         if key != nil &amp;&amp; cert != nil {
            res := toEnvoyKeyCertSecret(sr.ResourceName, key, cert)
            results = append(results, res)
            s.cache.Add(sr, res)
         } else {
            adsLog.Warnf(&quot;failed to fetch key and certificate for %v&quot;, sr.ResourceName)
         }
      }
   }
   return results
}
</code></pre>
<h4 id=322-client>3.2.2. Client</h4>
<h5 id=初始化-sds>初始化 SDS</h5>
<p>配置项：</p>
<pre><code class=language-go>// pilot-agent 更新证书周期是 24 小时
secretTTLEnv = env.RegisterDurationVar(&quot;SECRET_TTL&quot;, 24*time.Hour,
        &quot;The cert lifetime requested by istio agent&quot;).Get()
</code></pre>
<pre><code class=language-go>// pkg/istio-agent/agent.go

func (sa *Agent) Start(isSidecar bool, podNamespace string) (*sds.Server, error) {

    // 本地进程证书缓存
    // TODO: remove the caching, workload has a single cert
    if sa.WorkloadSecrets == nil {
        sa.WorkloadSecrets, _ = sa.newWorkloadSecretCache()
    }

    server, err := sds.NewServer(sa.secOpts, sa.WorkloadSecrets)


    // Start the local XDS generator.
    if sa.localXDSGenerator != nil {
        err = sa.startXDSGenerator(sa.proxyConfig, sa.WorkloadSecrets, podNamespace)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to start local xds generator: %v&quot;, err)
        }
    }

    if err = sa.initLocalDNSServer(isSidecar); err != nil {
        return nil, fmt.Errorf(&quot;failed to start local DNS server: %v&quot;, err)
    }
    if sa.cfg.ProxyXDSViaAgent {
        sa.xdsProxy, err = initXdsProxy(sa)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to start xds proxy: %v&quot;, err)
        }
    }
    return server, nil
}
</code></pre>
<p>此部分有异常多旧代码以及 TODO，推测是原来架构有 DaemonSet 部署的 Node Agent，目前架构中去除了，Node Agent 的工作由 pilot-agent 完成，只处理自身容器内 Envoy 的请求，自然不需要多复杂的缓存机制。</p>
<pre><code class=language-go>// security/pkg/nodeagent/sds/server.go

// NewServer creates and starts the Grpc server for SDS.
func NewServer(options *ca2.Options, workloadSecretCache ca2.SecretManager) (*Server, error) {
    s := &amp;Server{
        workloadSds: newSDSService(workloadSecretCache, options, options.FileMountedCerts),
    }
    if options.EnableWorkloadSDS {
        if err := s.initWorkloadSdsService(options); err != nil {
            sdsServiceLog.Errorf(&quot;Failed to initialize secret discovery service for workload proxies: %v&quot;, err)
            return nil, err
        }
    }
    return s, nil
}

func (s *Server) initWorkloadSdsService(options *ca2.Options) error { //nolint: unparam
    if options.GrpcServer != nil {
        s.grpcWorkloadServer = options.GrpcServer
        s.workloadSds.register(s.grpcWorkloadServer)
        return nil
    }
    s.grpcWorkloadServer = grpc.NewServer(s.grpcServerOptions(options)...)
    s.workloadSds.register(s.grpcWorkloadServer)

    var err error
    // Unix Domain Socket SDS 通信
    s.grpcWorkloadListener, err = uds.NewListener(options.WorkloadUDSPath)
    if err != nil {
        sdsServiceLog.Errorf(&quot;Failed to set up UDS path: %v&quot;, err)
    }

    go func() {
        sdsServiceLog.Info(&quot;Start SDS grpc server&quot;)
        ...
    }()

    return nil
}
</code></pre>
<p>这里可以看到本地监听 UDS，与 Envoy 通信。</p>
<h5 id=构建-csr>构建 CSR</h5>
<pre><code class=language-go>// pkg/istio-agent/agent.go

        ...
            // 获取 Istio CA 的证书，挂载的 Configmap
            caCertFile := sa.FindRootCAForCA()
        ...
             // 与 Istio CA 建立连接
        caClient, err = citadel.NewCitadelClient(sa.secOpts.CAEndpoint, tls, rootCert, sa.secOpts.ClusterID)
</code></pre>
<pre><code class=language-go>// security/pkg/nodeagent/cache/secretcache.go

// GenerateSecret generates new secret and cache the secret, this function is called by SDS.StreamSecrets
// and SDS.FetchSecret. Since credential passing from client may change, regenerate secret every time
// instead of reading from cache.
func (sc *SecretCache) GenerateSecret(ctx context.Context, connectionID, resourceName, token string) (*security.SecretItem, error) {

   // First try to generate secret from file.
   sdsFromFile, ns, err := sc.generateFileSecret(connKey, token)

   return ns, nil
}

func (sc *SecretCache) generateSecret(ctx context.Context, token string, connKey ConnKey, t time.Time) (*security.SecretItem, error) {
    ...
    // 构建 SPIFFE SAN 字段
    csrHostName := &amp;spiffe.Identity{
        TrustDomain:    sc.configOptions.TrustDomain,
        Namespace:      sc.configOptions.WorkloadNamespace,
        ServiceAccount: sc.configOptions.ServiceAccount,
    }

    // 构建 CSR 参数
    options := pkiutil.CertOptions{
        Host:       csrHostName.String(),
        RSAKeySize: keySize,
        PKCS8Key:   sc.configOptions.Pkcs8Keys,
        ECSigAlg:   pkiutil.SupportedECSignatureAlgorithms(sc.configOptions.ECCSigAlg),
    }

    // Generate the cert/key, send CSR to CA.
    csrPEM, keyPEM, err := pkiutil.GenCSR(options)

    // 调用 Istio CA 发送 CSR 请求
    certChainPEM, err := sc.sendRetriableRequest(ctx, csrPEM, exchangedToken, connKey, true)
...
}
</code></pre>
<p>流程：</p>
<ol>
<li>检查/创建私钥</li>
<li>构建 CSR（CSR 的 Host 是 SAN URI，即 SPIFFE ID）</li>
<li>请求 Istio CA</li>
</ol>
<h5 id=证书轮换>证书轮换</h5>
<p>两种情况：</p>
<ol>
<li>Workload 证书定期更新</li>
<li>CA 证书改变</li>
</ol>
<pre><code class=language-go>// security/pkg/nodeagent/cache/secretcache.go

func (sc *SecretCache) shouldRotate(secret *security.SecretItem) bool {
    // secret should be rotated before it expired.
    secretLifeTime := secret.ExpireTime.Sub(secret.CreatedTime)
    gracePeriod := time.Duration(sc.configOptions.SecretRotationGracePeriodRatio * float64(secretLifeTime))
    rotate := time.Now().After(secret.ExpireTime.Add(-gracePeriod))
    cacheLog.Debugf(&quot;Secret %s: lifetime: %v, graceperiod: %v, expiration: %v, should rotate: %v&quot;,
        secret.ResourceName, secretLifeTime, gracePeriod, secret.ExpireTime, rotate)
    return rotate
}
</code></pre>
<p>默认 Workload 证书 24 小时轮换。</p>
<pre><code class=language-go>// security/pkg/nodeagent/cache/secretcache.go

func (sc *SecretCache) addFileWatcher(file string, token string, connKey ConnKey) {
    ...

    if err := sc.certWatcher.Add(file); err != nil {
        ...
    }
    go func() {
        var timerC &lt;-chan time.Time
        for {
            select {
            case &lt;-timerC:
                timerC = nil
                // TODO(ramaraochavali): Remove the watchers for unused keys and certs.
                sc.certMutex.RLock()
                connKeys := sc.fileCerts[npath]
                sc.certMutex.RUnlock()
                // Update all connections that use this file.
                for ckey := range connKeys {
                    if _, ok := sc.secrets.Load(ckey); ok {
                        // Regenerate the Secret and trigger the callback that pushes the secrets to proxy.
                        // 重新生成证书
                        sc.generateFileSecret(ckey, token)
                    }
                }
            }
        }
    }()
}
</code></pre>
<p>监听根证书文件的变化：</p>
<pre><code class=language-go>// security/pkg/nodeagent/cache/secretcache.go        
    if sitem, err = sc.generateRootCertFromExistingFile(sc.existingRootCertFile, token, connKey, true); err == nil {
            sc.addFileWatcher(sc.existingRootCertFile, token, connKey)
        }
</code></pre>
<p>附 Istio 证书体系相关流程图<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>：</p>
<p>
<figure class=image>
<img src=/2021/10/istio-%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-pki-%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/images/cert-flow.png alt loading=lazy>
</figure></p>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>摘自《零信任网络 : 在不可信网络中构建安全系统》第 6 章—建立用户信任&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p><a href=https://istio.io/latest/docs/concepts/security/#secure-naming>Istio / Security - Secure naming</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p><a href=https://github.com/spiffe/spiffe/blob/main/standards/SPIFFE.md#1-introduction>Secure Production Identity Framework for Everyone (SPIFFE) - 1. Introduction</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p><a href=https://developer.aliyun.com/article/740195>Kubernetes 下零信任安全架构分析 - 蚂蚁零信任架构体系落地最佳实践</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p>摘自《零信任网络 : 在不可信网络中构建安全系统》第 2 章—信任管理&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:6 role=doc-endnote>
<p><a href=https://istio.io/latest/news/releases/1.8.x/announcing-1.8/>Announcing Istio 1.8</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:7 role=doc-endnote>
<p>摘自《零信任网络 : 在不可信网络中构建安全系统》第 8 章—建立流量信任&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:8 role=doc-endnote>
<p><a href=https://blog.csdn.net/yevvzi/article/details/107863433>Istio 证书签发流程</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<div class=post-meta>
<time datetime=" 2021-10-26" itemprop=datePublished>Oct 26, 2021</time>
</div>
</footer>
</article>
<script src=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.min.js></script>
<aside class=typeface-sans lang=zh-hans>
<nav class=toc></nav>
</aside>
<script>tocbot.init({tocSelector:'.toc',contentSelector:'article',headingSelector:'h1, h2, h3, h4, h5',hasInnerContainers:!0,collapseDepth:"3",positionFixedSelector:".toc",headingsOffset:10})</script>
</div><script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/filter-highlight-all/prism-filter-highlight-all.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script>Prism.plugins.filterHighlightAll.add(function(a){return a.language!=="mermaid"})</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.init({startOnLoad:!0},"pre code.language-mermaid",function(){const a=document.querySelectorAll('code.language-mermaid');for(const c of a){c.style.backgroundColor='initial';const b=c.parentNode;b.style.border='none',b.style.textAlign='center',window.darkmode&&!window.darkmode.isActivated()&&(b.style.backgroundColor='initial')}})</script>
</div>
</main><footer class=site-footer>
<div class=wrapper>
<div class=social-links>
<a class="social-link social-github" href=https://github.com/mayocream><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5C9.34 21.58 9.5 21.27 9.5 21 9.5 20.77 9.5 20.14 9.5 19.31 6.73 19.91 6.14 17.97 6.14 17.97c-.46-1.16-1.11-1.47-1.11-1.47C4.12 15.88 5.1 15.9 5.1 15.9 6.1 15.97 6.63 16.93 6.63 16.93 7.5 18.45 8.97 18 9.54 17.76 9.63 17.11 9.89 16.67 10.17 16.42c-2.22-.25-4.55-1.11-4.55-4.92.0-1.11.38-2 1.03-2.71C6.55 8.54 6.2 7.5 6.75 6.15c0 0 .84-.27 2.75 1.02C10.29 6.95 11.15 6.84 12 6.84s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02C17.8 7.5 17.45 8.54 17.35 8.79 18 9.5 18.38 10.39 18.38 11.5c0 3.82-2.34 4.66-4.57 4.91C14.17 16.72 14.5 17.33 14.5 18.26c0 1.34.0 2.42.0 2.74.0.27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg>
</a>
<a class="social-link social-rss" href=/index.xml target=_blank><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M6.18 15.64a2.18 2.18.0 012.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18.0 012.18-2.18M4 4.44A15.56 15.56.0 0119.56 20H16.73A12.73 12.73.0 004 7.27V4.44M4 10.1A9.9 9.9.0 0113.9 20H11.07A7.07 7.07.0 004 12.93V10.1z"/></svg>
</a>
</div>
<div class=credits>
Theme KAGAMI by Kamikat
</div>
</div>
</footer><script>(function(a){for(var a=Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')),b=0,c;b!=a.length;b++)c=a[b],c.innerHTML=c.innerHTML.replace(/[\u2000-\u206e⸀-\u2e7e⺀-\u2efe⼀-\u2fde⿰-\u2ffe\u3000-〾\u3040-ゞ゠-ヾ\u3100-\u312e\u3130-ㆎ㆐-㆞ㆠ-\u31be㇀-\u31eeㇰ-ㇾ㈀-㋾㌀-㏾㐀-\u4dbe一-\u9ffe\ua960-\ua97e가-\ud7ae\ud7b0-\ud7fe豈-\ufafe︰-﹎\uff00-￮]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud82c[\udc00-\udcfe]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e]/g,function(a){return'<span class="baseline-fix-block">'+a+'<'+'/span>'}),c.classList.remove('baseline-fix')})(Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')))</script>
<script type=text/javascript>const resize=function(){this.width=.5*(this.naturalWidth||this.width)};Array.prototype.forEach.call(document.querySelectorAll('.half-size, .retina2x'),function(a){a.naturalWidth?resize.call(a):a.onload=resize})</script>
<script src=https://cdn.jsdelivr.net/npm/twemoji@13.1.0/dist/twemoji.min.js></script>
<script>twemoji.parse(document.body,{folder:'svg',ext:'.svg'})</script>
</body>