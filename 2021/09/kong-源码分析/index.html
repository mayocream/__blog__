<!doctype html><html lang=ja><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>Kong 源码分析 - Mayo's Blog</title>
<meta name=description content="本文最初于 2020 年 9 月在公司内部发表，现整理并增加部分批注公开发布。 最开始加入公司 Infrastructure 团队时，迷茫的我接到的的一个任务就是学习 Lua 和 OpenRest">
<meta name=author content>
<link rel=preconnect href=https://cdn.jsdelivr.net>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Press+Start+2P" rel=stylesheet>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400&family=Noto+Sans+JP:wght@300;400&family=Noto+Sans+SC:wght@300;400&family=Noto+Serif:wght@300;400&family=Noto+Serif+JP:wght@300;400&family=Noto+Serif+SC:wght@300;400&family=Source+Code+Pro:wght@300;400" rel=stylesheet>
<link rel=stylesheet href="/bundle.css?v=1737040591" media=all>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.css>
<link rel=icon href=https://github.com/mayocream.png><meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://mayo.rocks/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/><meta property="og:title" content="Kong 源码分析">
<meta property="og:description" content="本文最初于 2020 年 9 月在公司内部发表，现整理并增加部分批注公开发布。 最开始加入公司 Infrastructure 团队时，迷茫的我接到的的一个任务就是学习 Lua 和 OpenRest">
<meta property="og:type" content="article">
<meta property="og:url" content="https://mayo.rocks/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-21T04:30:00+08:00">
<meta property="article:modified_time" content="2021-09-21T04:30:00+08:00"><meta property="og:site_name" content="Mayo's Blog">
</head>
</html>
<body><script src=https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>const opts={bottom:'32px',right:'unset',left:'32px',time:'0.3s',mixColor:'#fff',backgroundColor:'#fff',buttonColorDark:'#100f2c',buttonColorLight:'#fff',saveInCookies:!0,label:'🌓',autoMatchOsTheme:!0};let darkmode;window.matchMedia('only screen and (min-width: 680px)').matches?(darkmode=new Darkmode(opts),darkmode.showWidget()):(localStorage.removeItem('darkmode'),darkmode=new Darkmode(opts)),window.darkmode=darkmode,document.addEventListener('DOMContentLoaded',function(){document.body.style.opacity=1})</script>
<main class=page-content aria-label=Content>
<div class=wrapper><nav class=site-nav>
<a class=page-link href=/posts/>Posts</a>
<a class=page-link href=/about/>About</a>
</nav><header class=post-header>
<a class=site-title href=https://mayo.rocks>Mayo's Blog</a>
<h1 class="post-title baseline-fix typeface-sans" lang=zh-hans itemprop="name headline">Kong 源码分析</h1>
</header>
<div class=post-cover aria-label=Cover>
<div class=post-cover-wrapper>
<img src alt>
</div>
<div class=cover-meta></div>
</div>
<div class=post-layout>
<article class="post typeface-sans" lang=zh-hans itemscope itemtype=http://schema.org/BlogPosting>
<div class=post-content itemprop=articleBody>
<p>本文最初于 2020 年 9 月在公司内部发表，现整理并增加部分批注公开发布。</p>
<p>最开始加入公司 Infrastructure 团队时，迷茫的我接到的的一个任务就是学习 Lua 和 <a href=https://github.com/openresty/lua-nginx-module>OpenResty</a>，当时收到了两本书籍的 PDF 文件，要求尽快理解学习，能够掌握 <a href=https://github.com/Kong/kong>Kong</a>，并且具有研发能力。</p>
<p>当时我还没有怎么接触开源社区，能力只停留在 Git Clone，大概花了 2 周时间，我学习 Lua 基本语法后，开始阅读 Kong 项目的源码，并找到几个切入点梳理了源码分析文档，也应该正是这个成果让组长认同了我，这之后我负责公司 API Gateway 的开发，以及相关的落地工作。</p>
<p>那么本文针对 Kong 的启动流程、插件机制、缓存机制和请求的生命周期做了详细的阐述，不过仍有欠缺的是代理转发功能，例如负载均衡、健康检查、服务发现等，不过介于当时的我还是个懵懂的新人，这里就先原谅我自己了 🐾。</p>
<p>继这篇文章之后，我还撰写了 Kong Ingress Controller 源码分析，后续还有 APISIX 的源码分析哦。</p>
<h2 id=1-概述>1. 概述</h2>
<p>本文针对的是 Kong 2.1 版本（Stable）。</p>
<p>我阅读并作出中文注释的 Commits 可以在这里看到：
<a href="https://github.com/mayocream/kong/commits?author=huanghan39">https://github.com/mayocream/kong/commits?author=mayocream</a></p>
<p><strong>Kong（OpenResty）的执行阶段</strong>：</p>
<p>
<figure class=image>
<img src=/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/openresty_phases.png alt loading=lazy>
</figure></p>
<p>Kong 的插件机制也是基于 OpenResty 的生命周期，只不过是其在上层做了些许封装。</p>
<p><strong>Kong 的数据库关联关系</strong>：</p>
<p>
<figure class=image>
<img src=/2021/09/kong-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/kong_db.png alt loading=lazy>
</figure></p>
<p>Kong 虽然标称自己是 Cloud Native 项目<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，也上榜了 CNCF <a href=https://landscape.cncf.io/>全景图</a>，但是它还依赖于传统的数据库 PostgreSQL，并且还自定义了许多 function，相比于 APISIX 背后储存 Etcd 要弱了许多。比起 Etcd 能建立 HTTP 长连接 Watch 数据变化，Kong 只能依赖定时的轮询从数据库更新状态，数据库高可用也相比 Etcd 集群要复杂得多。</p>
<h2 id=2-配置文件>2. 配置文件</h2>
<p>Kong 在启动阶段会解析 <a href=https://github.com/kong/kong/tree/master/kong/templates><code>kong/templates</code></a> 目录下的 <code>.lua</code> 模板文件，注入环境变量和 <code>kong.conf</code> 覆盖配置，生成 Nginx 启动的配置文件 <code>nginx.conf</code>。</p>
<p>结构如下：</p>
<pre><code class=language-yaml>pid pids/nginx.pid;
error_log logs/error.log notice;

# injected nginx_main_* directives

env SKYWALKING_URL;

events {
    # injected nginx_events_* directives
    multi_accept on;
    worker_connections 16384;
}

http {
    lua_package_path       './?.lua;./?/init.lua;;;;';
    lua_package_cpath      ';;;';

    lua_shared_dict kong                        5m;
    lua_shared_dict kong_locks                  8m;
	...

    # injected nginx_http_* directives
    client_body_buffer_size 8k;

    init_by_lua_block {
        Kong = require 'kong'
        Kong.init()
    }

    init_worker_by_lua_block {
        Kong.init_worker()
    }

    upstream kong_upstream {
        server 0.0.0.1;

        # injected nginx_upstream_* directives

        balancer_by_lua_block {
            Kong.balancer()
        }
    }

	# Kong Proxy
    server {
        server_name kong;
		...
    }

	# Kong Admin API
    server {
        server_name kong_admin;
        ...
    }


}
</code></pre>
<p>Kong 定义了 <code>NGINX_MAIN_XXX</code>，诸如此类的环境变量，在解析配置阶段会加载到 <code>nginx.conf</code> 的指定位置，能够避免直接修改模板文件。</p>
<p>例如：</p>
<pre><code class=language-bash># 在 main 块里定义 env 变量
$ export NGINX_MAIN_ENV SKYWALKING_URL;
# 创建新的 lua shared dict
$ export NGINX_HTTP_Lua_SHARED_DICT tracing_buffer 128m;
</code></pre>
<p>Kong <a href=https://docs.konghq.com/2.1.x/configuration/>官方的配置文档</a>已经非常详尽，解释了各个参数代表的含义。</p>
<p>这里补充一点，通常我们需要定义多个 Shared dict，配置写法需要改成这种丑陋的形式：</p>
<pre><code>nginx_http_lua_shared_dict = cache_buffer_one 128m; lua_shared_dict cache_buffer_two 128m
</code></pre>
<h2 id=3-初始化>3. 初始化</h2>
<h3 id=31-数据库初始化>3.1. 数据库初始化</h3>
<p><code>Kong.init()</code> 方法中初始化数据库相关：</p>
<pre><code class=language-lua>  -- 数据库连接相关
  local db = assert(DB.new(config))
  assert(db:init_connector())
  kong.db = db
</code></pre>
<p><code>DB.new()</code> 方法中依次调用了 <code>Schema.new()</code>、<code>Entity.new()</code>、<code>DAO.new()</code> 方法，下面一个个来说明。</p>
<h4 id=311-schema>3.1.1. Schema</h4>
<p>Kong 的 Schema 数据结构体位于 <code>db/schema/entities</code> 下，就 <code>routes.lua</code> 为例：</p>
<pre><code class=language-lua>local typedefs = require &quot;kong.db.schema.typedefs&quot;


return {
  name         = &quot;routes&quot;,
  primary_key  = { &quot;id&quot; },
  endpoint_key = &quot;name&quot;,
  workspaceable = true,
  subschema_key = &quot;protocols&quot;,

  fields = {
    { id             = typedefs.uuid, },
    { created_at     = typedefs.auto_timestamp_s },
    { updated_at     = typedefs.auto_timestamp_s },
    { name           = typedefs.name },
    { protocols      = { type     = &quot;set&quot;,
                         len_min  = 1,
                         required = true,
                         elements = typedefs.protocol,
                         mutually_exclusive_subsets = {
                           { &quot;http&quot;, &quot;https&quot; },
                           { &quot;tcp&quot;, &quot;tls&quot; },
                           { &quot;grpc&quot;, &quot;grpcs&quot; },
                         },
                         default = { &quot;http&quot;, &quot;https&quot; }, -- TODO: different default depending on service's scheme
                       }, },
    { methods        = typedefs.methods },
    { hosts          = typedefs.hosts },
    { paths          = typedefs.paths },
    { headers        = typedefs.headers },
    { https_redirect_status_code = { type = &quot;integer&quot;,
                                     one_of = { 426, 301, 302, 307, 308 },
                                     default = 426, required = true,
                                   }, },
    { regex_priority = { type = &quot;integer&quot;, default = 0 }, },
    { strip_path     = { type = &quot;boolean&quot;, default = true }, },
    { path_handling  = { type = &quot;string&quot;, default = &quot;v0&quot;, one_of = { &quot;v0&quot;, &quot;v1&quot; }, }, },
    { preserve_host  = { type = &quot;boolean&quot;, default = false }, },
    { snis = { type = &quot;set&quot;,
               elements = typedefs.sni }, },
    { sources = typedefs.sources },
    { destinations = typedefs.destinations },
    { tags             = typedefs.tags },
    { service = { type = &quot;foreign&quot;, reference = &quot;services&quot; }, },
  },

  entity_checks = {
    { conditional = { if_field = &quot;protocols&quot;,
                      if_match = { elements = { type = &quot;string&quot;, not_one_of = { &quot;grpcs&quot;, &quot;https&quot;, &quot;tls&quot; }}},
                      then_field = &quot;snis&quot;,
                      then_match = { len_eq = 0 },
                      then_err = &quot;'snis' can only be set when 'protocols' is 'grpcs', 'https' or 'tls'&quot;,
                    }},
                  }
}

</code></pre>
<p><code>primary_key</code> 是在数据库中主键也是当 <code>cache_key</code> 未定义时的默认 <code>cache_key</code>。</p>
<p>有 <code>type=foreign</code> 的情况，entity 加载时会当作 subschema 加载进来。</p>
<p>插件不同于其他 entity，有特定 cache_key。</p>
<pre><code class=language-lua>  name = &quot;plugins&quot;,
  primary_key = { &quot;id&quot; },
  cache_key = { &quot;name&quot;, &quot;route&quot;, &quot;service&quot;, &quot;consumer&quot; },
</code></pre>
<p>Cache 相关操作中调用 <code>Entity.cache_key()</code> 获取。</p>
<pre><code class=language-lua>    local cache_key = dao:cache_key(entity)
    local ok, err = cache:safe_set(cache_key, entity)
</code></pre>
<p>具体生成 <code>cache_key</code> 的方法，返回一个字符串作为缓存 key。</p>
<pre><code class=language-lua>function DAO:cache_key(key, arg2, arg3, arg4, arg5, ws_id)

  if self.schema.workspaceable then
    ws_id = ws_id or workspaces.get_workspace_id()
  end

  -- Fast path: passing the cache_key/primary_key entries in
  -- order as arguments, this produces the same result as
  -- the generic code below, but building the cache key
  -- becomes a single string.format operation
  if type(key) == &quot;string&quot; then
    return fmt(&quot;%s:%s:%s:%s:%s:%s:%s&quot;, self.schema.name,
               key == nil and &quot;&quot; or key,
               arg2 == nil and &quot;&quot; or arg2,
               arg3 == nil and &quot;&quot; or arg3,
               arg4 == nil and &quot;&quot; or arg4,
               arg5 == nil and &quot;&quot; or arg5,
               ws_id == nil and &quot;&quot; or ws_id)
  end

  -- Generic path: build the cache key from the fields
  -- listed in cache_key or primary_key

  if type(key) ~= &quot;table&quot; then
    error(&quot;key must be a string or an entity table&quot;, 2)
  end

  if key.ws_id then
    ws_id = key.ws_id
  end

  local values = new_tab(7, 0)
  values[1] = self.schema.name
  local source = self.schema.cache_key or self.schema.primary_key

  local i = 2
  for _, name in ipairs(source) do
    local field = self.schema.fields[name]
    local value = key[name]
    if value == null or value == nil then
      value = &quot;&quot;
    elseif field.type == &quot;foreign&quot; then
      -- FIXME extract foreign key, do not assume `id`
      value = value.id
    end
    values[i] = tostring(value)
    i = i + 1
  end
  for n = i, 6 do
    values[n] = &quot;&quot;
  end

  values[7] = ws_id or &quot;&quot;

  return concat(values, &quot;:&quot;)
end
</code></pre>
<p><code>schema/init.lua</code> 中定义了 schema 相关操作的基本方法：</p>
<pre><code class=language-lua>-- each_field() 用于遍历 schema 的 fields
-- 是 schema 相关操作最频繁的
function Schema:each_field(values)
  local i = 1

  local subschema
  if values then
    subschema = get_subschema(self, values)
  end

  return function()
    local item = self.fields[i]
    if not item then
      return nil
    end
    local key = next(item)
    local field = resolve_field(self, key, item[key], subschema)
    i = i + 1
    return key, field
  end
end
</code></pre>
<p><code>Schema.new()</code> 方法中通过元组设置 <code>__index</code> 让结构体继承 Schema 下定义的一系列操作方法。</p>
<pre><code class=language-lua>function Schema.new(definition, is_subschema)
  if not definition then
    return nil, validation_errors.SCHEMA_NO_DEFINITION
  end

  if not definition.fields then
    return nil, validation_errors.SCHEMA_NO_FIELDS
  end

  local self = copy(definition)

  -- 继承 Schema 下定义的一系列操作方法
  setmetatable(self, Schema)

  -- entity 缓存的 cache_key，
  -- 如果没有这个字段，则默认使用 schema 定义的
  -- primary_key 来作为 cache_key
  -- cache_key 是个数组，
  -- 这里只是分开储存
  if self.cache_key then
    self.cache_key_set = {}
    for _, name in ipairs(self.cache_key) do
      self.cache_key_set[name] = true
    end
  end


  -- 通过元组 __index 方法调用 Schema:each_field() 方法
  -- 遍历 schema 的 fields table
  for key, field in self:each_field() do
    -- Also give access to fields by name
    self.fields[key] = field
    if field.type == &quot;record&quot; and field.fields then
      allow_record_fields_by_name(field)
    end

    -- 如果有外键
    -- 则加载外键关联的 schema 进来
    if field.type == &quot;foreign&quot; then
      local err
      field.schema, err = get_foreign_schema_for_field(field)
      if not field.schema then
        return nil, err
      end

      if not is_subschema then
        -- Store the inverse relation for implementing constraints
        local constraints = assert(_cache[field.reference]).constraints
        table.insert(constraints, {
          schema     = self,
          field_name = key,
          on_delete  = field.on_delete,
        })
      end
    end
  end

  if self.workspaceable and self.name then
    if not _workspaceable[self.name] then
      _workspaceable[self.name] = true
      table.insert(_workspaceable, { schema = self })
    end
  end

  if self.name then
    -- do not reset the constraints list if a schema in reloaded
    if not _cache[self.name] then
      _cache[self.name] = {
        constraints = {},
      }
    end
    -- but always update the schema object in cache
    _cache[self.name].schema = self
  end

  return self
end
</code></pre>
<p>用于下级继承的元组，虚晃一枪。</p>
<pre><code class=language-lua>local Schema       = {}
Schema.__index     = Schema
</code></pre>
<h4 id=312-entity>3.1.2. Entity</h4>
<p>Entity 只是简单对 Schema 进行一层封装。</p>
<pre><code class=language-lua>-- definition 是 schema 结构体
function Entity.new(definition)

  -- 初始化 Schema 对象
  local self, err = Schema.new(definition)
  if not self then
    return nil, err
  end

  -- 遍历 schema fields
  for name, field in self:each_field() do
    if field.nilable then
      return nil, entity_errors.NO_NILABLE:format(name)
    end

    if field.abstract then
      goto continue
    end

    if field.type == &quot;map&quot; then
      if field.keys.type ~= &quot;string&quot; then
        return nil, entity_errors.MAP_KEY_STRINGS_ONLY:format(name)
      end

    elseif field.type == &quot;record&quot; then
      make_records_required(field)

    elseif field.type == &quot;function&quot; then
      return nil, entity_errors.NO_FUNCTIONS:format(name)
    end

    ::continue::
  end

  self.new_subschema = Entity.new_subschema

  return self
end

</code></pre>
<p>Entity 对象随后被加载到 <code>DB.new()</code> 函数中：</p>
<pre><code class=language-lua>local schemas = {}

do
  -- load schemas
  -- core entities are for now the only source of schemas.
  -- TODO: support schemas from plugins entities as well.

  -- 载入核心 entity，为什么是核心 entity
  -- 因为还有 plugin 自定义的 entity
  -- 这些 entity 是 Kong 自身的
  for _, entity_name in ipairs(constants.CORE_ENTITIES) do

    -- 加载 schema（数据结构体）
    local entity_schema = require(&quot;kong.db.schema.entities.&quot; .. entity_name)

    -- validate core entities schema via metaschema
    local ok, err_t = MetaSchema:validate(entity_schema)
    if not ok then
      return nil, fmt(&quot;schema of entity '%s' is invalid: %s&quot;, entity_name,
                      tostring(errors:schema_violation(err_t)))
    end

    -- 加载 entity 对象
    local entity, err = Entity.new(entity_schema)
    if not entity then
      return nil, fmt(&quot;schema of entity '%s' is invalid: %s&quot;, entity_name,
                      err)
    end
    schemas[entity_name] = entity

    -- load core entities subschemas
    local subschemas
    ok, subschemas = utils.load_module_if_exists(&quot;kong.db.schema.entities.&quot; .. entity_name .. &quot;_subschemas&quot;)
    if ok then
      for name, subschema in pairs(subschemas) do
        local ok, err = entity:new_subschema(name, subschema)
        if not ok then
          return nil, (&quot;error initializing schema for %s: %s&quot;):format(entity_name, err)
        end
      end
    end
  end
end
</code></pre>
<h4 id=313-dao>3.1.3. DAO</h4>
<p><code>db/dao/init.lua</code> 中定义了一系列对数据库操作的方法，例如：</p>
<pre><code class=language-lua>function DAO:select(primary_key, options)
function DAO:page(size, offset, options)
function DAO:each(size, options)
function DAO:insert(entity, options)
function DAO:update(primary_key, entity, options)
function DAO:delete(primary_key, options)
...
</code></pre>
<p><code>DAO.new()</code> 会创建一个包含 db 连接信息，entity 的 table。</p>
<pre><code class=language-lua>-- schema 参数是 Entity 对象
--  DB 结构体：  local self   = {
  --    daos       = daos,       -- each of those has the connector singleton
  --    strategies = strategies,
  --    connector  = connector,
  --    strategy   = strategy,
  --    errors     = errors,
  --    infos      = connector:infos(),
  --    kong_config = kong_config,
  --  }
function _M.new(db, schema, strategy, errors)
  local fk_methods = generate_foreign_key_methods(schema)
  -- 继承 DAO 基础方法
  local super      = setmetatable(fk_methods, DAO)

  local self = {
    db         = db,
    schema     = schema,
    strategy   = strategy,
    errors     = errors,
    pagination = utils.shallow_copy(defaults.pagination),
    super      = super,
  }

  if schema.dao then
    -- 插件自定义的 dao
    local custom_dao = require(schema.dao)
    for name, method in pairs(custom_dao) do
      self[name] = method
    end
  end

  return setmetatable(self, { __index = super })
end
</code></pre>
<p>在 <code>db\init.lua</code> 中加载所有 DAO 对象。</p>
<pre><code class=language-lua>  do
    -- load DAOs

    for _, schema in pairs(schemas) do
      local strategy = strategies[schema.name]
      if not strategy then
        return nil, fmt(&quot;no strategy found for schema '%s'&quot;, schema.name)
      end

      -- 储存 daos
      daos[schema.name] = DAO.new(self, schema, strategy, errors)
    end
  end
</code></pre>
<p>和上面结构一样，<code>DB.new()</code> 中最后为 table 设置元组 __index 方法。</p>
<pre><code class=language-lua>  -- 设置元组 __index 方法
  -- 访问不存在的对象则先
  -- DB.xxx 再访问 DB.daos.xxx
  return setmetatable(self, DB)


local DB = {}
DB.__index = function(self, k)
  -- rawget 为不调用元组 __index 方法，直接获取原数据
  return DB[k] or rawget(self, &quot;daos&quot;)[k]
end
</code></pre>
<p>Kong 中其他地方调用数据库方法，操作符为 <code>kong.db.services:each_fields()</code>，即实际调用 <code>daos.services</code>、<code>entity:each_fields()</code>（实际是 <code>Schema:each_fields()</code>）。</p>
<p>DAO 下面还有封装的数据库操作层，例如 postgresql 生成 SQL 语句的方法，这里就不赘述了。</p>
<p>DAO 这一层一层的封装看得我是真的脑壳痛，IDE 还没有对 lua 的智能提示，按住 Ctrl 毛都显示不出来。</p>
<h3 id=32-缓存构建>3.2. 缓存构建</h3>
<p><code>init_by_lua</code> 阶段初始化 Master 进程，进行解析配置文件、连接数据库、清空共享内存、构建路由缓存等操作。</p>
<p><code>reset_kong_shm</code> 代码块里清理共享内存。</p>
<pre><code class=language-lua>    local shms = {
      &quot;kong&quot;,
      &quot;kong_locks&quot;,
      &quot;kong_healthchecks&quot;,
      &quot;kong_process_events&quot;,
      &quot;kong_cluster_events&quot;,
      &quot;kong_rate_limiting_counters&quot;,
      &quot;kong_core_db_cache&quot; .. suffix,
      &quot;kong_core_db_cache_miss&quot; .. suffix,
      &quot;kong_db_cache&quot; .. suffix,
      &quot;kong_db_cache_miss&quot; .. suffix,
      &quot;kong_clustering&quot;,
    }

    for _, shm in ipairs(shms) do
      local dict = ngx.shared[shm]
      -- 清空共享内存
      if dict then
        dict:flush_all()
        dict:flush_expired(0)
      end
    end
</code></pre>
<h4 id=321-路由缓存>3.2.1. 路由缓存</h4>
<pre><code class=language-lua>  else
    -- DB 模式
    local default_ws = db.workspaces:select_by_name(&quot;default&quot;)
    kong.default_workspace = default_ws and default_ws.id

    local ok, err = runloop.build_plugins_iterator(&quot;init&quot;)
    if not ok then
      error(&quot;error building initial plugins: &quot; .. tostring(err))
    end

    -- 初始化路由
    -- 构建路由缓存
    assert(runloop.build_router(&quot;init&quot;))
  end

  db:close()
end
</code></pre>
<p>DB 模式下最后一步会调用 <code>runloop.build_router("init")</code> 构建路由缓存。</p>
<p>构建路由缓存过程中，判断 Kong 是否已经初始化过 Cache 组件，<code>init</code> 阶段没有完成初始化 Cache，则创建一个 Lua table 缓存路由信息。<code>build_services_init_cache()</code> 方法会分页加载所有 Service 到 table 中，对取出来的 Services，判断当前使用的 Nginx 模式（http/stream）是否对应路由指定的协议，对应则取出 Service 对象，与 Route 进行关联。最后传递给 <code>Router.new()</code> 方法通过算法建立树形结构建立路由索引。</p>
<p>Kong 基于 Nginx Subsystem 支持的协议对应关系：</p>
<ul>
<li>http/https -> http</li>
<li>grpc/grpcs -> http</li>
<li>tcp/tls -> stream</li>
</ul>
<pre><code class=language-lua>  build_router = function(version)
    local db = kong.db
    -- table 储存所有的 route-service 数据
    local routes, i = {}, 0

    local err
    -- The router is initially created on init phase, where kong.core_cache is
    -- still not ready. For those cases, use a plain Lua table as a cache
    -- instead
    -- init 阶段 core_cache 还没有初始化完成
    -- 这里使用 table 储存
    local services_init_cache = {}
    if not kong.core_cache and db.strategy ~= &quot;off&quot; then
      -- 获取所有的 services，使用默认的分页参数
      services_init_cache, err = build_services_init_cache(db)
      if err then
        services_init_cache = {}
        log(WARN, &quot;could not build services init cache: &quot;, err)
      end
    end

    local counter = 0
    local page_size = db.routes.pagination.page_size
    for route, err in db.routes:each(nil, GLOBAL_QUERY_OPTS) do
      if err then
        return nil, &quot;could not load routes: &quot; .. err
      end

      -- 检查 router 数据是否已经变化
      -- 通过检查 router hash 是否一致判断
      -- 如果已经变化则退出函数
      if db.strategy ~= &quot;off&quot; then
        if kong.core_cache and counter &gt; 0 and counter % page_size == 0 then
          local new_version, err = get_router_version()
          if err then
            return nil, &quot;failed to retrieve router version: &quot; .. err
          end

          if new_version ~= version then
            return nil, &quot;router was changed while rebuilding it&quot;
          end
        end
      end

      -- subsystem 是否支持当前路由的协议
      if should_process_route(route) then
        -- 获取 route 的 service
        local service, err = get_service_for_route(db, route, services_init_cache)
        if err then
          return nil, err
        end

        local r = {
          route   = route,
          service = service,
        }

        i = i + 1
        -- 储存所有的 route-service
        routes[i] = r
      end

      counter = counter + 1
    end

    local new_router, err = Router.new(routes)
    if not new_router then
      return nil, &quot;could not create router: &quot; .. err
    end

    -- router 实例
    router = new_router

    if version then
      router_version = version
    end

    -- LEGACY - singletons module is deprecated
    singletons.router = router
    -- /LEGACY

    return true
  end
</code></pre>
<p>构建路由缓存过程中，判断 Kong 是否已经初始化过 Cache 组件，<code>init</code> 阶段没有完成初始化 Cache，则创建一个 Lua table 缓存 services。</p>
<pre><code class=language-lua>  -- 以 [service.id] = service
  -- 结构储存到 table 中
  local function build_services_init_cache(db)
    local services_init_cache = {}

    for service, err in db.services:each(nil, GLOBAL_QUERY_OPTS) do
      if err then
        return nil, err
      end

      services_init_cache[service.id] = service
    end

    return services_init_cache
  end
</code></pre>
<p><code>build_services_init_cache(db)</code> 方法，调用 <code>DAO:each()</code> 函数，使用默认分页参数 <code>page_size=1000</code>，进行分页获取，再返回可迭代的单条记录。这里因为 <code>init_by_lua</code> 阶段没有初始化缓存（<code>kong.core_cache</code> ），所以使用 Lua table 储存缓存数据。</p>
<pre><code class=language-lua>function DAO:each(size, options)
  if size ~= nil then
    validate_size_type(size)
  end

  -- 获取分页条件，有默认值
  options = get_pagination_options(self, options)

  if size ~= nil then
    local ok, err = validate_size_value(size, options.pagination.max_page_size)
    if not ok then
      local err_t = self.errors:invalid_size(err)
      return nil, tostring(err_t), err_t
    end

  else
    size = options.pagination.page_size
  end

  local ok, errors = validate_options_value(self, options)
  if not ok then
    local err_t = self.errors:invalid_options(errors)
    return nil, tostring(err_t), err_t
  end

  local pager = function(size, offset, options)
    return self.strategy:page(size, offset, options)
  end

  return iteration.by_row(self, pager, size, options)
end
</code></pre>
<p>默认分页参数在 <code>db/strategies/connector.lua</code> 文件中：</p>
<pre><code class=language-lua>local Connector = {
  defaults = {
    -- 默认分页条件
    pagination = {
      page_size     = 1000,
      max_page_size = 50000,
    },
  },
}
</code></pre>
<p>接下来会遍历所有的 Routes，逐个调用 <code>should_process_route()</code> 和 <code>get_service_for_route()</code> 方法，前者会判断 Nginx Subsystem 是否和 Route 协议一致，后者先在缓存中查找 Service，如果缓存中不存在则从数据库中获取。</p>
<pre><code class=language-lua>  local function get_service_for_route(db, route, services_init_cache)
    -- route 关联的 service 外键
    local service_pk = route.service
    if not service_pk then
      return nil
    end

    -- 查找缓存 table 里的 service
    local id = service_pk.id
    local service = services_init_cache[id]
    if service then
      return service
    end

    local err

    -- kong.core_cache is available, not in init phase
    if kong.core_cache then
      -- 通过 mlcache 查询 service
      local cache_key = db.services:cache_key(service_pk.id, nil, nil, nil, nil,
                                              route.ws_id)
      -- 查询 cache 获取，没有获取到则调用 load_service_from_db 获取
      service, err = kong.core_cache:get(cache_key, TTL_ZERO,
                                    load_service_from_db, service_pk)

    else -- init phase, kong.core_cache not available

      -- A new service/route has been inserted while the initial route
      -- was being created, on init (perhaps by a different Kong node).
      -- Load the service individually and update services_init_cache with it
      -- 直接查询数据库获取 service
      service, err = load_service_from_db(service_pk)
      services_init_cache[id] = service
    end

    if err then
      return nil, &quot;error raised while finding service for route (&quot; .. route.id .. &quot;): &quot; ..
                  err

    elseif not service then
      return nil, &quot;could not find service for route (&quot; .. route.id .. &quot;)&quot;
    end


    -- TODO: this should not be needed as the schema should check it already
    if SUBSYSTEMS[service.protocol] ~= subsystem then
      log(WARN, &quot;service with protocol '&quot;, service.protocol,
                &quot;' cannot be used with '&quot;, subsystem, &quot;' subsystem&quot;)

      return nil
    end

    return service
  end

</code></pre>
<p><code>load_service_from_db()</code> 方法中只是简单调用 <code>DAO:select()</code> 方法，取出 Service 同时缓存到 <code>services_init_cache</code> table 中，不更新 <code>Kong.core_cache</code> 组件。</p>
<p>对数据库实体对象的处理中，只有<code>create</code> 、<code>update</code>、<code>delete</code> 会通过事件广播到其他 Worker 同步，后面事件的一节我们会详细阐述。</p>
<p>接下来将 <code>{router, service}</code> 数组传入 <code>router.iua</code> 中 <code>Router.new()</code> 函数处理。</p>
<pre><code class=language-lua>local new_router, err = Router.new(routes)
if not new_router then
    return nil, &quot;could not create router: &quot; .. err
end

-- 绑定 router 实例
router = new_router
</code></pre>
<p>具体构建路由索引的过程在 <code>router.lua</code> 中的 <code>_M.new(routes)</code> 函数，使用 <strong><a href=https://github.com/openresty/lua-resty-lrucache>lua-resty-lrucache</a></strong> 包缓存，对路由和 Service 组合通过算法进行排序，构建索引，将诸如 <code>{cache_key: {route, service}}</code> 结构存入缓存中，返回 Router 实例。</p>
<p>路由索引 Key 的构建方法：</p>
<pre><code class=language-lua>    local cache_key = req_method .. &quot;|&quot; .. req_uri .. &quot;|&quot; .. req_host ..
                      &quot;|&quot; .. ctx.src_ip .. &quot;|&quot; .. ctx.src_port ..
                      &quot;|&quot; .. ctx.dst_ip .. &quot;|&quot; .. ctx.dst_port ..
                      &quot;|&quot; .. ctx.sni
</code></pre>
<p>Router 实例由 Master 进程构建，并 fork 到各个 Worker 进程使用。</p>
<p>Worker 执行完共享内存的构建后，注册定时任务，定时重建缓存。</p>
<pre><code class=language-lua>      -- 定时重建路由缓存
      if kong.db.strategy ~= &quot;off&quot; then
        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          -- Don't wait for the semaphore (timeout = 0) when updating via the
          -- timer.
          -- If the semaphore is locked, that means that the rebuild is
          -- already ongoing.
          local ok, err = rebuild_router(ROUTER_ASYNC_OPTS)
          if not ok then
            log(ERR, &quot;could not rebuild router via timer: &quot;, err)
          end
        end)

        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          local ok, err = rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)
          if not ok then
            log(ERR, &quot;could not rebuild plugins iterator via timer: &quot;, err)
          end
        end)
      end
</code></pre>
<h4 id=322-entity-缓存>3.2.2. Entity 缓存</h4>
<p>这里首先介绍一下 <strong><a href=https://github.com/thibaultcha/lua-resty-mlcache>lua-resty-mlcache</a></strong> 这个缓存库，该库基于 <a href=https://github.com/openresty/lua-nginx-module#lua_shared_dict>lua_shared_dict</a> 和 <a href=https://github.com/openresty/lua-resty-lrucache>lua-resty-lrucache</a> 做了两层缓存，Worker 会有自己的进程级别的 LRU 缓存，首先会在这一层进行查询，其次使用共享内存进行缓存，最后提供 callback 从数据库查询，使用 <a href=https://github.com/openresty/lua-resty-lock>lua-resty-lock</a> 库创建锁只允许单个进程执行 callback。</p>
<p>mlcache 架构图：</p>
<pre><code>┌─────────────────────────────────────────────────┐
│ Nginx                                           │
│       ┌───────────┐ ┌───────────┐ ┌───────────┐ │
│       │worker     │ │worker     │ │worker     │ │
│ L1    │           │ │           │ │           │ │
│       │ Lua cache │ │ Lua cache │ │ Lua cache │ │
│       └───────────┘ └───────────┘ └───────────┘ │
│             │             │             │       │
│             ▼             ▼             ▼       │
│       ┌───────────────────────────────────────┐ │
│       │                                       │ │
│ L2    │           lua_shared_dict             │ │
│       │                                       │ │
│       └───────────────────────────────────────┘ │
│                           │ mutex               │
│                           ▼                     │
│                  ┌──────────────────┐           │
│                  │     callback     │           │
│                  └────────┬─────────┘           │
└───────────────────────────┼─────────────────────┘
                            │
  L3                        │   I/O fetch
                            ▼

                   Database, API, DNS, Disk, any I/O...
</code></pre>
<p><code>Kong.init_worker()</code> 中进行初始化缓存：</p>
<pre><code class=language-lua>  -- 初始化基于共享内存的 cache
  local cache, err = kong_global.init_cache(kong.configuration, cluster_events, worker_events)
  if not cache then
    stash_init_worker_error(&quot;failed to instantiate 'kong.cache' module: &quot; ..
                            err)
    return
  end
  kong.cache = cache

  local core_cache, err = kong_global.init_core_cache(kong.configuration, cluster_events, worker_events)
  if not core_cache then
    stash_init_worker_error(&quot;failed to instantiate 'kong.core_cache' module: &quot; ..
                            err)
    return
  end
  kong.core_cache = core_cache

  ok, err = runloop.set_init_versions_in_cache()
  if not ok then
    stash_init_worker_error(err) -- 'err' fully formatted
    return
  end
</code></pre>
<p><code>global.init_cache()</code> 结构如下：</p>
<pre><code class=language-lua>function _GLOBAL.init_cache(kong_config, cluster_events, worker_events)
  local db_cache_ttl = kong_config.db_cache_ttl
  local db_cache_neg_ttl = kong_config.db_cache_neg_ttl
  local cache_pages = 1
  if kong_config.database == &quot;off&quot; then
    db_cache_ttl = 0
    db_cache_neg_ttl = 0
    cache_pages = 2
  end

  return kong_cache.new {
    shm_name          = &quot;kong_db_cache&quot;,
    cluster_events    = cluster_events,
    worker_events     = worker_events,
    ttl               = db_cache_ttl,
    neg_ttl           = db_cache_neg_ttl or db_cache_ttl,
    resurrect_ttl     = kong_config.resurrect_ttl,
    cache_pages       = cache_pages,
    resty_lock_opts   = {
      exptime = 10,
      timeout = 5,
    },
  }
end
</code></pre>
<p>最终会调用 <code>cache.lua</code> 中 <code>_M.new()</code> 进行必要参数的验证，检测共享内存块是否可以访问，关联集群事件和 Worker 事件，定义序列化和反序列化的方法，对 mlcache 进行一层封装。</p>
<pre><code class=language-lua>function _M.new(opts)
  -- opts validation

  opts = opts or {}

  local mlcaches = {}
  local shm_names = {}

  for i = 1, opts.cache_pages or 1 do
    local channel_name  = (i == 1) and &quot;mlcache&quot;                 or &quot;mlcache_2&quot;
    local shm_name      = (i == 1) and opts.shm_name             or opts.shm_name .. &quot;_2&quot;
    local shm_miss_name = (i == 1) and opts.shm_name .. &quot;_miss&quot;  or opts.shm_name .. &quot;_miss_2&quot;

    if ngx.shared[shm_name] then
      local mlcache, err = resty_mlcache.new(shm_name, shm_name, {
        shm_miss         = shm_miss_name,
        shm_locks        = &quot;kong_locks&quot;,
        shm_set_retries  = 3,
        lru_size         = LRU_SIZE,
        ttl              = max(opts.ttl     or 3600, 0),
        neg_ttl          = max(opts.neg_ttl or 300,  0),
        resurrect_ttl    = opts.resurrect_ttl or 30,
        resty_lock_opts  = opts.resty_lock_opts,
        ipc = { -- 进程间通信的函数绑定
          register_listeners = function(events)
            for _, event_t in pairs(events) do
              opts.worker_events.register(function(data)
                event_t.handler(data)
              end, channel_name, event_t.channel)
            end
          end,
          broadcast = function(channel, data)
            local ok, err = opts.worker_events.post(channel_name, channel, data)
            if not ok then
              log(ERR, &quot;failed to post event '&quot;, channel_name, &quot;', '&quot;,
                       channel, &quot;': &quot;, err)
            end
          end
        }
      })
      if not mlcache then
        return nil, &quot;failed to instantiate mlcache: &quot; .. err
      end
      mlcaches[i] = mlcache
      shm_names[i] = shm_name
    end
  end

  local curr_mlcache = 1

  if opts.cache_pages == 2 then
    curr_mlcache = ngx.shared.kong:get(&quot;kong:cache:&quot; .. opts.shm_name .. &quot;:curr_mlcache&quot;) or 1
  end

  local self          = {
    cluster_events    = opts.cluster_events,
    mlcache           = mlcaches[curr_mlcache],
    mlcaches          = mlcaches,
    shm_names         = shm_names,
    curr_mlcache      = curr_mlcache,
  }

  local ok, err = self.cluster_events:subscribe(&quot;invalidations&quot;, function(key)
    log(DEBUG, &quot;received invalidate event from cluster for key: '&quot;, key, &quot;'&quot;)
    self:invalidate_local(key)
  end)
  if not ok then
    return nil, &quot;failed to subscribe to invalidations cluster events &quot; ..
                &quot;channel: &quot; .. err
  end

  _init[opts.shm_name] = true

  return setmetatable(self, mt)
end
</code></pre>
<p>初始化完缓存模块后，Worker 会根据配置文件中的 <code>db_cache_warmup_entities</code> 加载指定的数据库资源到内存进行缓存，默认配置会缓存 <code>services, plugins</code>。</p>
<p><code>LRU_SIZE</code> 值为 500,000，单位是 item，设置最大能储存的 item 数量，这个值表示单个 Worker LRU Cache 最大占用 500M 内存。</p>
<p>Worker 会根据配置项加载数据库实体到共享内存缓存。</p>
<pre><code class=language-lua>local function execute_cache_warmup(kong_config)
  if kong_config.database == &quot;off&quot; then
    return true
  end

  -- 只在一个 worker 上执行操作
  -- 加载数据库实体到共享内存缓存
  if ngx.worker.id() == 0 then
    local ok, err = cache_warmup.execute(kong_config.db_cache_warmup_entities)
    if not ok then
      return nil, err
    end
  end

  return true
end
</code></pre>
<p>这里只在一个 Worker 进程上加载数据库数据，随后同步到其他的 Worker 上。</p>
<p><code>cache_warmup.execute()</code> 里做基本信息的检测，随后调用 <code>cache_warmup_single_entity(dao)</code> 方法。</p>
<pre><code class=language-lua>-- 加载数据库实体到缓存，以实现更快的访问速度
-- 在 Worker 初始化阶段运行
-- 默认加载 service, plugins
-- 大小受配置 mem_cache_size 影响
-- Loads entities from the database into the cache, for rapid subsequent
-- access. This function is intented to be used during worker initialization.
function cache_warmup.execute(entities)
  if not kong.cache or not kong.core_cache then
    return true
  end

  for _, entity_name in ipairs(entities) do
    if entity_name == &quot;routes&quot; then
      -- do not spend shm memory by caching individual Routes entries
      -- because the routes are kept in-memory by building the router object
      kong.log.notice(&quot;the 'routes' entry is ignored in the list of &quot;,
                      &quot;'db_cache_warmup_entities' because Kong &quot;,
                      &quot;caches routes in memory separately&quot;)
      goto continue
    end

    local dao = kong.db[entity_name]
    if not (type(dao) == &quot;table&quot; and dao.schema) then
      kong.log.warn(entity_name, &quot; is not a valid entity name, please check &quot;,
                    &quot;the value of 'db_cache_warmup_entities'&quot;)
      goto continue
    end

    local ok, err = cache_warmup_single_entity(dao)
    if not ok then
      if err == &quot;no memory&quot; then
        kong.log.warn(&quot;cache warmup has been stopped because cache &quot;,
                      &quot;memory is exhausted, please consider increasing &quot;,
                      &quot;the value of 'mem_cache_size' (currently at &quot;,
                      kong.configuration.mem_cache_size, &quot;)&quot;)

        return true
      end
      return nil, err
    end

    ::continue::
  end

  return true
end
</code></pre>
<p>不缓存 Routes，因为 Route 已经在上一节中构建为路由索引树，通过 fork 到所有的 Worker 内存里了。</p>
<pre><code class=language-lua>local function cache_warmup_single_entity(dao)
  local entity_name = dao.schema.name

  -- 选定储存地方 cache/core_cache
  local cache_store = constants.ENTITY_CACHE_STORE[entity_name]
  -- cache 全局对象
  local cache = kong[cache_store]

  ngx.log(ngx.NOTICE, &quot;Preloading '&quot;, entity_name, &quot;' into the &quot;, cache_store, &quot;...&quot;)

  local start = ngx.now()

  local hosts_array, hosts_set, host_count
  if entity_name == &quot;services&quot; then
    hosts_array = {}
    hosts_set = {}
    host_count = 0
  end

  for entity, err in dao:each(nil, GLOBAL_QUERY_OPTS) do
    if err then
      return nil, err
    end

    if entity_name == &quot;services&quot; then
      if utils.hostname_type(entity.host) == &quot;name&quot;
         and hosts_set[entity.host] == nil then
        host_count = host_count + 1
        hosts_array[host_count] = entity.host
        hosts_set[entity.host] = true
      end
    end

    -- 获取 cache_key
    local cache_key = dao:cache_key(entity)

    -- 调用 mlcache 的 safe_set 方法，
    -- 内存不足会报错
    local ok, err = cache:safe_set(cache_key, entity)
    if not ok then
      return nil, err
    end
  end

  if entity_name == &quot;services&quot; and host_count &gt; 0 then
    ngx.timer.at(0, warmup_dns, hosts_array, host_count)
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, &quot;finished preloading '&quot;, entity_name,
                      &quot;' into the &quot;, cache_store, &quot; (in &quot;, tostring(elapsed), &quot;ms)&quot;)
  return true
end
</code></pre>
<p><code>cache_warmup_single_entity()</code> 会加载该 dao 所有的数据到内存中，<code>set</code> 方法会分发事件同步数据到其他的 Worker 上，最终每个 Worker 都会缓存一份。</p>
<h3 id=33-事件订阅>3.3. 事件订阅</h3>
<p><code>Kong.init_worker()</code> 中初始化 Worker 事件和集群事件。</p>
<pre><code class=language-lua>  local worker_events, err = kong_global.init_worker_events()
  if not worker_events then
    stash_init_worker_error(&quot;failed to instantiate 'kong.worker_events' &quot; ..
                            &quot;module: &quot; .. err)
    return
  end
  kong.worker_events = worker_events

  local cluster_events, err = kong_global.init_cluster_events(kong.configuration, kong.db)
  if not cluster_events then
    stash_init_worker_error(&quot;failed to instantiate 'kong.cluster_events' &quot; ..
                            &quot;module: &quot; .. err)
    return
  end
  kong.cluster_events = cluster_events
</code></pre>
<p>Worker 事件内部是使用 <strong><a href=https://github.com/Kong/lua-resty-worker-events>lua-resty-worker-events</a></strong> 库实现的进程间事件处理，原理是通过共享内存储存事件，每秒拉取共享内存中的事件，进行处理。</p>
<pre><code class=language-lua>function _GLOBAL.init_worker_events()
  -- Note: worker_events will not work correctly if required at the top of the file.
  --       It must be required right here, inside the init function
  local worker_events = require &quot;resty.worker.events&quot;

  local ok, err = worker_events.configure {
    shm = &quot;kong_process_events&quot;, -- defined by &quot;lua_shared_dict&quot;
    timeout = 5,            -- life time of event data in shm
    interval = 1,           -- poll interval (seconds)

    wait_interval = 0.010,  -- wait before retry fetching event data
    wait_max = 0.5,         -- max wait time before discarding event
  }
  if not ok then
    return nil, err
  end

  return worker_events
end
</code></pre>
<p>集群事件（多个 Kong 之间的通信）是通过将事件储存在数据库中，定时轮询数据库查询事件，进行处理。</p>
<pre><code class=language-lua>function _GLOBAL.init_cluster_events(kong_config, db)
  return kong_cluster_events.new({
    db            = db,
    poll_interval = kong_config.db_update_frequency,
    poll_offset   = kong_config.db_update_propagation,
    poll_delay    = kong_config.db_update_propagation,
  })
end
</code></pre>
<p>从这里可以看到集群事件是通过数据库表实现的：</p>
<pre><code class=language-lua>function _M:broadcast(channel, data, delay)
  if type(channel) ~= &quot;string&quot; then
    return nil, &quot;channel must be a string&quot;
  end

  if type(data) ~= &quot;string&quot; then
    return nil, &quot;data must be a string&quot;
  end

  if delay and type(delay) ~= &quot;number&quot; then
    return nil, &quot;delay must be a number&quot;

  elseif self.poll_delay &gt; 0 then
    delay = self.poll_delay
  end

  -- insert event row

  --log(DEBUG, &quot;broadcasting on channel: '&quot;, channel, &quot;' data: &quot;, data,
  --           &quot; with delay: &quot;, delay and delay or &quot;none&quot;)

  local ok, err = self.strategy:insert(self.node_id, channel, nil, data, delay)
  if not ok then
    return nil, err
  end

  return true
end


function _M:subscribe(channel, cb, start_polling)
  if type(channel) ~= &quot;string&quot; then
    return error(&quot;channel must be a string&quot;)
  end

  if type(cb) ~= &quot;function&quot; then
    return error(&quot;callback must be a function&quot;)
  end

  if not self.callbacks[channel] then
    self.callbacks[channel] = { cb }

    insert(self.channels, channel)

  else
    insert(self.callbacks[channel], cb)
  end

  if start_polling == nil then
    start_polling = true
  end

  if not self.polling and start_polling and self.use_polling then
    -- start recurring polling timer

    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      return nil, &quot;failed to start polling timer: &quot; .. err
    end

    self.polling = true
  end

  return true
end
</code></pre>
<p>在 <code>cache.lua</code> 中集群事件订阅 cache 失效事件，内部调用 mlcache 的 delete 方法，同步到所有的 Worker 上。</p>
<pre><code class=language-lua>  local ok, err = self.cluster_events:subscribe(&quot;invalidations&quot;, function(key)
    log(DEBUG, &quot;received invalidate event from cluster for key: '&quot;, key, &quot;'&quot;)
    self:invalidate_local(key)
  end)


function _M:invalidate_local(key, shadow)
  if type(key) ~= &quot;string&quot; then
    error(&quot;key must be a string&quot;, 2)
  end

  log(DEBUG, &quot;invalidating (local): '&quot;, key, &quot;'&quot;)

  local current_page = self.curr_mlcache or 1
  local delete_page
  if shadow and #self.mlcaches == 2 then
    delete_page = current_page == 1 and 2 or 1
  else
    delete_page = current_page
  end

  local ok, err = self.mlcaches[delete_page]:delete(key)
  if not ok then
    log(ERR, &quot;failed to delete entity from node cache: &quot;, err)
  end
end
</code></pre>
<p>这部分主要描述 Kong 初始化过程中的事件相关操作，主要是初始化事件订阅，关联到 mlcache 的 IPC 进程间通信，订阅 cache 的失效事件，并关联 DAO 的事件发布。</p>
<pre><code class=language-lua>function DB:set_events_handler(events)
  for _, dao in pairs(self.daos) do
    dao.events = events
  end
end
</code></pre>
<h2 id=4-事件分发>4. 事件分发</h2>
<p>Kong 中众多部分通过非阻塞的 <code>ngx.timer.at()</code> 和 <code>ngx.timer.every()</code> 函数执行定时任务。这一部分较为分散，主要叙述 Kong 执行非阻塞一次性事件处理，和典型的定时任务。</p>
<h3 id=41-单次任务>4.1. 单次任务</h3>
<h4 id=411-dns-解析>4.1.1. DNS 解析</h4>
<p>在 <code>cache_warmup.lua</code> 中缓存 services 对象时，Kong 会非阻塞地获取 services 中 host 对应的 ip。</p>
<pre><code class=language-lua>  if entity_name == &quot;services&quot; and host_count &gt; 0 then
    ngx.timer.at(0, warmup_dns, hosts_array, host_count)
  end

local function warmup_dns(premature, hosts, count)
  if premature then
    return
  end

  ngx.log(ngx.NOTICE, &quot;warming up DNS entries ...&quot;)

  local start = ngx.now()

  for i = 1, count do
    kong.dns.toip(hosts[i])
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, &quot;finished warming up DNS entries&quot;,
                      &quot;' into the cache (in &quot;, tostring(elapsed), &quot;ms)&quot;)
end
</code></pre>
<p>Kong 内部 dns 模块使用 <strong><a href=https://github.com/Kong/lua-resty-dns-client>lua-resty-dns-client</a></strong>，这个库也是由 Kong 开源的，特色有 <code>toip</code> 函数会根据 dns 返回 ip 的权重配置加权轮询的权重，储存 dns 查询的结果在内存中。</p>
<p><code>warmup_dns()</code> 内调用 <code>kong.dns.toip()</code> 方法：</p>
<pre><code class=language-lua>local function warmup_dns(premature, hosts, count)
  if premature then
    return
  end

  ngx.log(ngx.NOTICE, &quot;warming up DNS entries ...&quot;)

  local start = ngx.now()

  for i = 1, count do
    kong.dns.toip(hosts[i])
  end

  local elapsed = math.floor((ngx.now() - start) * 1000)

  ngx.log(ngx.NOTICE, &quot;finished warming up DNS entries&quot;,
                      &quot;' into the cache (in &quot;, tostring(elapsed), &quot;ms)&quot;)
end
</code></pre>
<h3 id=42-定时任务>4.2. 定时任务</h3>
<h4 id=421-集群任务>4.2.1. 集群任务</h4>
<p><code>cluster_events/init.lua</code> 中集群事情订阅函数里启用定时器轮询数据库集群事件表。</p>
<pre><code class=language-lua>function _M:subscribe(channel, cb, start_polling)
  if type(channel) ~= &quot;string&quot; then
    return error(&quot;channel must be a string&quot;)
  end

  if type(cb) ~= &quot;function&quot; then
    return error(&quot;callback must be a function&quot;)
  end

  if not self.callbacks[channel] then
    self.callbacks[channel] = { cb }

    insert(self.channels, channel)

  else
    insert(self.callbacks[channel], cb)
  end

  if start_polling == nil then
    start_polling = true
  end

  if not self.polling and start_polling and self.use_polling then
    -- start recurring polling timer

    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      return nil, &quot;failed to start polling timer: &quot; .. err
    end

    self.polling = true
  end

  return true
end
</code></pre>
<p>这里因为要在每次循环调用时进行锁的判断，所以没有使用 <code>ngx.timer.every()</code> 函数，而是用无限循环调用 <code>ngx.timer.at()</code>。</p>
<pre><code class=language-lua>poll_handler = function(premature, self)
  if premature or not self.polling then
    -- set self.polling to false to stop a polling loop
    return
  end

  if not get_lock(self) then
    local ok, err = timer_at(self.poll_interval, poll_handler, self)
    if not ok then
      log(CRIT, &quot;failed to start recurring polling timer: &quot;, err)
    end

    return
  end

  -- single worker

  local pok, perr, err = pcall(poll, self)
  if not pok then
    log(ERR, &quot;poll() threw an error: &quot;, perr)

  elseif not perr then
    log(ERR, &quot;failed to poll: &quot;, err)
  end

  -- unlock

  self.shm:delete(POLL_RUNNING_LOCK_KEY)

  local ok, err = timer_at(self.poll_interval, poll_handler, self)
  if not ok then
    log(CRIT, &quot;failed to start recurring polling timer: &quot;, err)
  end
end
</code></pre>
<p>锁通过共享内存事件，保证只有一个 Worker 执行单次任务。</p>
<pre><code class=language-lua>local function get_lock(self)
  -- check if a poll is not currently running, to ensure we don't start
  -- another poll while a worker is still stuck in its own polling (in
  -- case it is being slow)
  -- we still add an exptime to this lock in case something goes horribly
  -- wrong, to ensure other workers can poll new events
  -- a poll cannot take more than max(poll_interval * 5, 10) -- 10s min
  local ok, err = self.shm:safe_add(POLL_RUNNING_LOCK_KEY, true,
                                    max(self.poll_interval * 5, 10))
  if not ok then
    if err ~= &quot;exists&quot; then
      log(ERR, &quot;failed to acquire poll_running lock: &quot;, err)
    end
    -- else
    --   log(DEBUG, &quot;failed to acquire poll_running lock: &quot;,
    --              &quot;a worker still holds the lock&quot;)

    return false
  end

  if self.poll_interval &gt; 0.001 then
    -- check if interval of `poll_interval` has elapsed already, to ensure
    -- we do not run the poll when a previous poll was quickly executed, but
    -- another worker got the timer trigger a bit too late.
    ok, err = self.shm:safe_add(POLL_INTERVAL_LOCK_KEY, true,
                                self.poll_interval - 0.001)
    if not ok then
      if err ~= &quot;exists&quot; then
        log(ERR, &quot;failed to acquire poll_interval lock: &quot;, err)
      end
      -- else
      --   log(DEBUG, &quot;failed to acquire poll_interval lock: &quot;,
      --              &quot;not enough time elapsed since last poll&quot;)

      self.shm:delete(POLL_RUNNING_LOCK_KEY)

      return false
    end
  end

  return true
end
</code></pre>
<h4 id=422-数据库-ttl>4.2.2. 数据库 TTL</h4>
<p>为给 PostgreSQL 加上 TTL，Kong 在 <code>init_worker</code> 阶段调用数据库层 <code>db/strategies/postgres/connector.lua</code> 中 <code>init_worker()</code> 函数。</p>
<pre><code class=language-lua>-- 以下省略部分内容，只展示关键部分
function _mt:init_worker(strategies)
  if ngx.worker.id() == 0 then

      cleanup_statements[i] = concat {
        &quot;  DELETE FROM &quot;,
        self:escape_identifier(table_name),
        &quot; WHERE &quot;,
        column_name,
        &quot; &lt; CURRENT_TIMESTAMP AT TIME ZONE 'UTC';&quot;
      }

    local cleanup_statement = concat(cleanup_statements, &quot;\n&quot;)

    return timer_every(60, function(premature)

      local ok, err, _, num_queries = self:query(cleanup_statement)
      if not ok then
        if num_queries then
          for i = num_queries + 1, cleanup_statements_count do
            local statement = cleanup_statements[i]
            local ok, err = self:query(statement)
            if not ok then
              if err then
                log(WARN, &quot;unable to clean expired rows from table '&quot;,
                          sorted_strategies[i], &quot;' on PostgreSQL database (&quot;,
                          err, &quot;)&quot;)
              else
                log(WARN, &quot;unable to clean expired rows from table '&quot;,
                          sorted_strategies[i], &quot;' on PostgreSQL database&quot;)
              end
            end
          end

        else
          log(ERR, &quot;unable to clean expired rows from PostgreSQL database (&quot;, err, &quot;)&quot;)
        end
      end
    end)
  end

  return true
end
</code></pre>
<p>数据库初始化时新增一个 <code>timer</code>，在协程中调用回调函数，删除 TTL 过期的 rows。</p>
<h4 id=423-更新路由索引>4.2.3. 更新路由索引</h4>
<p><code>kong.init_worker()</code> 会添加定时任务，定时更新缓存。</p>
<pre><code class=language-lua>      -- 定时重建路由缓存
      if kong.db.strategy ~= &quot;off&quot; then
        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          -- Don't wait for the semaphore (timeout = 0) when updating via the
          -- timer.
          -- If the semaphore is locked, that means that the rebuild is
          -- already ongoing.
          local ok, err = rebuild_router(ROUTER_ASYNC_OPTS)
          if not ok then
            log(ERR, &quot;could not rebuild router via timer: &quot;, err)
          end
        end)

        timer_every(worker_state_update_frequency, function(premature)
          if premature then
            return
          end

          local ok, err = rebuild_plugins_iterator(PLUGINS_ITERATOR_ASYNC_OPTS)
          if not ok then
            log(ERR, &quot;could not rebuild plugins iterator via timer: &quot;, err)
          end
        end)
      end
</code></pre>
<p>实际调用顺序是开一个 cosocket 协程，判断 routes 是否有变化，变化则重构路由缓存。</p>
<pre><code class=language-lua>  rebuild_router = function(opts)
    return rebuild(&quot;router&quot;, update_router, router_version, opts)
  end

local function rebuild(name, callback, version, opts)
  local current_version, err = kong.core_cache:get(name .. &quot;:version&quot;, TTL_ZERO,
                                                   utils.uuid)
  if err then
    return nil, &quot;failed to retrieve &quot; .. name .. &quot; version: &quot; .. err
  end

  if current_version == version then
    return true
  end

  -- 开一个 cosocket 协程调用 callback
  return concurrency.with_coroutine_mutex(opts, callback)
end

  update_router = function()
    -- we might not need to rebuild the router (if we were not
    -- the first request in this process to enter this code path)
    -- check again and rebuild only if necessary
    local version, err = get_router_version()
    if err then
      return nil, &quot;failed to retrieve router version: &quot; .. err
    end

    if version == router_version then
      return true
    end

    local ok, err = build_router(version)
    if not ok then
      return nil, --[[ 'err' fully formatted ]] err
    end

    return true
  end
</code></pre>
<p>最终还会调用到 <code>build_router()</code> 方法，我们已经在 1.2.1 中描述过。</p>
<h2 id=5-事件处理>5. 事件处理</h2>
<p>Worker 间的事件处理使用 <code>lua-resty-worker-events</code> 库。</p>
<p>事件订阅函数：<code>events.register(callback, source, event1, event2, ...)</code>，callback 方法 <code>callback = function(data, event, source, pid)</code>。</p>
<p>事件发布函数：<code>success, err = events.post(source, event, data, unique)</code></p>
<h3 id=51-数据库事件>5.1. 数据库事件</h3>
<p><code>db/dao/init.lua</code> 中定义了 DAO 相关的操作方法，我已经在 1.1.3 中简单阐述过了。</p>
<p>数据库相关实体的 CRUD（其实没有R）事件最后会调用 <code>DAO:post_crud_event()</code> 方法广播事件。</p>
<pre><code class=language-lua>function DAO:post_crud_event(operation, entity, old_entity, options)
  if options and options.no_broadcast_crud_event then
    return
  end

  if self.events then
    local entity_without_nulls
    if entity then
      entity_without_nulls = remove_nulls(utils.deep_copy(entity, false))
    end

    local old_entity_without_nulls
    if old_entity then
      old_entity_without_nulls = remove_nulls(utils.deep_copy(old_entity, false))
    end

    local ok, err = self.events.post_local(&quot;dao:crud&quot;, operation, {
      operation  = operation,
      schema     = self.schema,
      entity     = entity_without_nulls,
      old_entity = old_entity_without_nulls,
    })
    if not ok then
      log(ERR, &quot;[db] failed to propagate CRUD operation: &quot;, err)
    end
  end
end
</code></pre>
<p>在 <code>dao:crud</code> 通道发布了一个事件，operation 类型有 create、update、delete。</p>
<p><code>runloop/handler.lua</code> 中 <code>register_events()</code> 会在 <code>kong.init_worker()</code> 中被调用，此时会订阅数据库相关事件，添加处理函数。</p>
<pre><code class=language-lua>  worker_events.register(function(data)
    if not data.schema then
      log(ERR, &quot;[events] missing schema in crud subscriber&quot;)
      return
    end

    if not data.entity then
      log(ERR, &quot;[events] missing entity in crud subscriber&quot;)
      return
    end

    -- invalidate this entity anywhere it is cached if it has a
    -- caching key
    -- 如果 entity 有 cache_key 则让它失效
    -- 基本上也只有 entity schema 定义出错的情况下才不会有 cache_key

    local cache_key = db[data.schema.name]:cache_key(data.entity)
    local cache_obj = kong[constants.ENTITY_CACHE_STORE[data.schema.name]]

    if cache_key then
      cache_obj:invalidate(cache_key)
    end

    -- if we had an update, but the cache key was part of what was updated,
    -- we need to invalidate the previous entity as well

    if data.old_entity then
      local old_cache_key = db[data.schema.name]:cache_key(data.old_entity)
      if old_cache_key and cache_key ~= old_cache_key then
        cache_obj:invalidate(old_cache_key)
      end
    end

    if not data.operation then
      log(ERR, &quot;[events] missing operation in crud subscriber&quot;)
      return
    end

    -- public worker events propagation

    -- 获取 schema 名字
    local entity_channel           = data.schema.table or data.schema.name
    local entity_operation_channel = fmt(&quot;%s:%s&quot;, entity_channel,
      data.operation)

    -- crud:routes
    local ok, err = worker_events.post_local(&quot;crud&quot;, entity_channel, data)
    if not ok then
      log(ERR, &quot;[events] could not broadcast crud event: &quot;, err)
      return
    end

    -- crud:routes:create
    ok, err = worker_events.post_local(&quot;crud&quot;, entity_operation_channel, data)
    if not ok then
      log(ERR, &quot;[events] could not broadcast crud event: &quot;, err)
      return
    end
  end, &quot;dao:crud&quot;)
</code></pre>
<p>CRUD（没有 R）事件处理流程：调用 <code>cache:invalidate()</code> 方法，方法内部发布了一个 worker 级事件，通知 worker 进程删除该数据，还会发布一个集群事件，在集群间同步删除数据。</p>
<pre><code class=language-lua>  -- 修改了 Routes 后会清空 router:version 缓存，
  -- 会导致重新构建路由表，详情查看 2.2.3
  worker_events.register(function()
    log(DEBUG, &quot;[events] Route updated, invalidating router&quot;)
    core_cache:invalidate(&quot;router:version&quot;)
  end, &quot;crud&quot;, &quot;routes&quot;)

...其他对象同理
</code></pre>
<h2 id=6-插件加载>6. 插件加载</h2>
<h3 id=61-插件读取>6.1. 插件读取</h3>
<p><code>init</code> 阶段会加载配置文件中 <code>plugins=bundled,skywalking-intergrator</code> 的插件列表，调用 Lua <code>require</code> 加载对应的包。（所有的插件包都要求在 <code>kong.plugins</code> 下）</p>
<pre><code class=language-lua>function Plugins:load_plugin_schemas(plugin_set)
  self.handlers = nil

  local go_plugins_cnt = 0
  local handlers = {}
  local errs

  -- load installed plugins
  for plugin in pairs(plugin_set) do
    local handler, err = load_plugin(self, plugin)

    if handler then
      if type(handler.is) == &quot;function&quot; and handler:is(BasePlugin) then
        -- Backwards-compatibility for 0.x and 1.x plugins inheriting from the
        -- BasePlugin class.
        -- TODO: deprecate &amp; remove
        handler = handler()
      end

      if handler._go then
        go_plugins_cnt = go_plugins_cnt + 1
      end

      handlers[plugin] = handler

    else
      errs = errs or {}
      table.insert(errs, &quot;on plugin '&quot; .. plugin .. &quot;': &quot; .. tostring(err))
    end
  end

  if errs then
    return nil, &quot;error loading plugin schemas: &quot; .. table.concat(errs, &quot;; &quot;)
  end

  reports.add_immutable_value(&quot;go_plugins_cnt&quot;, go_plugins_cnt)

  self.handlers = handlers

  return true
end
</code></pre>
<p>所有插件的 Handler 函数会被储存在 <code>kong.db.plugins.handlers</code>，数据格式为 <code>{plugin_name: handler}</code>。</p>
<p>所有的插件会储存到 Worker 进程上，周期性进行同步更新。</p>
<p>我整理了插件表加载到 Lua table 的结构，输出成 YAML，方便理解：</p>
<pre><code class=language-yaml>map:
  plugin_name: true

combos:
  plugin_name:
    # both: {}
    both:
      route_id: service_id
    # routes: {}
    routes:
      route_id: true
    # services: {}
    services:
      service_id: true
    0: true # 全局插件
    1: true # 路由插件
    2: true # Service 插件
    3: true # 路由+Service
    4: true # Consumer 插件
    5: true # 路由+Consumer 插件
    6: true # 路由+Service+Consumer 插件

loaded:
  plugin_name:
    handler:
      phase_name: func()
</code></pre>
<h3 id=62-插件调用>6.2. 插件调用</h3>
<p>插件不直接和路由进行绑定，插件有自己的生命周期，和 Kong 的生命周期基本相同。在 Kong 生命周期的各个阶段会调用插件的对应方法。</p>
<p>插件只在调用阶段进行判断，是否关联当前 Route、Service、和 Consumer，有则从数据库读取插件关联的配置项（插件 Entity），并使用 <code>kong.core_cache</code> 进行缓存。</p>
<pre><code class=language-lua>local function load_configuration_through_combos(ctx, combos, plugin)
  local plugin_configuration
  local name = plugin.name

  local route    = ctx.route
  local service  = ctx.service
  local consumer = ctx.authenticated_consumer

  if route and plugin.no_route then
    route = nil
  end
  if service and plugin.no_service then
    service = nil
  end
  if consumer and plugin.no_consumer then
    consumer = nil
  end

  local    route_id = route    and    route.id or nil
  local  service_id = service  and  service.id or nil
  local consumer_id = consumer and consumer.id or nil

  if kong.db.strategy == &quot;off&quot; then
	...
  else
    if route_id and service_id and consumer_id and combos[COMBO_RSC]
      and combos.both[route_id] == service_id
    then
      plugin_configuration = load_configuration(ctx, name, route_id, service_id,
                                                consumer_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    if consumer_id and combos[COMBO_C] then
      plugin_configuration = load_configuration(ctx, name, nil, nil, consumer_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    if route_id and combos[COMBO_R] and combos.routes[route_id] then
      plugin_configuration = load_configuration(ctx, name, route_id)
      if plugin_configuration then
        return plugin_configuration
      end
    end

    ...

    if combos[COMBO_GLOBAL] then
      return load_configuration(ctx, name)
    end
  end
end
</code></pre>
<p>这里会查询当前 Service、Route 和 Consumer 是否与某个插件配对，成功则加载对应的配置项：</p>
<pre><code class=language-lua>--- Load the configuration for a plugin entry.
-- Given a Route, Service, Consumer and a plugin name, retrieve the plugin's
-- configuration if it exists. Results are cached in ngx.dict
-- @param[type=string] name Name of the plugin being tested for configuration.
-- @param[type=string] route_id Id of the route being proxied.
-- @param[type=string] service_id Id of the service being proxied.
-- @param[type=string] consumer_id Id of the donsumer making the request (if any).
-- @treturn table Plugin configuration, if retrieved.
local function load_configuration(ctx,
                                  name,
                                  route_id,
                                  service_id,
                                  consumer_id)
  local ws_id = workspaces.get_workspace_id() or kong.default_workspace
  local key = kong.db.plugins:cache_key(name,
                                        route_id,
                                        service_id,
                                        consumer_id,
                                        nil,
                                        ws_id)
  local plugin, err = kong.core_cache:get(key,
                                          nil,
                                          load_plugin_from_db,
                                          key)
  if err then
    ctx.delay_response = false
    ngx.log(ngx.ERR, tostring(err))
    return ngx.exit(ngx.ERROR)
  end

  if not plugin or not plugin.enabled then
    return
  end

  local cfg = plugin.config or {}

  if not cfg.__key__ then
    cfg.__key__ = key
    cfg.__seq__ = next_seq
    next_seq = next_seq + 1
  end

  cfg.route_id    = plugin.route and plugin.route.id
  cfg.service_id  = plugin.service and plugin.service.id
  cfg.consumer_id = plugin.consumer and plugin.consumer.id

  return cfg
end
</code></pre>
<p>插件的调用有两种方式：</p>
<ol>
<li>同步调用</li>
<li>异步调用</li>
</ol>
<p>除了 <code>access_by_lua</code> 阶段，都是使用同步调用：</p>
<pre><code class=language-lua>local function execute_plugins_iterator(plugins_iterator, phase, ctx)
  local old_ws = ctx and ctx.workspace
  for plugin, configuration in plugins_iterator:iterate(phase, ctx) do
    if ctx then
      if plugin.handler._go then
        ctx.ran_go_plugin = true
      end

      kong_global.set_named_ctx(kong, &quot;plugin&quot;, plugin.handler)
    end

    kong_global.set_namespaced_log(kong, plugin.name)
    -- 这里是同步调用
    plugin.handler[phase](plugin.handler, configuration)
    kong_global.reset_log(kong)

    if ctx then
      ctx.workspace = old_ws
    end
  end
end
</code></pre>
<p>而在 <code>access_by_lua</code> 阶段，使用协程异步调用：</p>
<pre><code class=language-lua>  for plugin, plugin_conf in plugins_iterator:iterate(&quot;access&quot;, ctx) do
    if plugin.handler._go then
      ctx.ran_go_plugin = true
    end

    if not ctx.delayed_response then
      kong_global.set_named_ctx(kong, &quot;plugin&quot;, plugin.handler)
      kong_global.set_namespaced_log(kong, plugin.name)

      -- 使用 Lua coroutine 开启协程异步调用插件函数
      local err = coroutine.wrap(plugin.handler.access)(plugin.handler, plugin_conf)
      if err then
        kong.log.err(err)
        ctx.delayed_response = {
          status_code = 500,
          content     = { message  = &quot;An unexpected error occurred&quot; },
        }
      end

      kong_global.reset_log(kong)
    end
    ctx.workspace = old_ws
  end
</code></pre>
<h2 id=7-缓存机制>7. 缓存机制</h2>
<p>本节根据我对 Kong 源码的分析，做一个缓存机制的小回顾。</p>
<p>Kong 针对缓存有这些操作：</p>
<ul>
<li>初始化缓存块</li>
<li>预载加载数据库内容到缓存</li>
<li>访问时才加载的数据内容添加到缓存</li>
<li>timer 定时更新缓存</li>
<li>数据库 CRUD 操作删除缓存</li>
<li>集群/Worker 间同步缓存</li>
</ul>
<p>缓存加载内容：</p>
<p>默认配置下，Kong 将路由表和 Routes 全量加载到每个 Worker 的内存，Services 和 Plugins 全量加载到每个 Worker 的内存和共享内存中。Upstreams 和 Targets 根据负载均衡器的解析及时从数据库获取，加载到内存和共享内存中。</p>
<p>上述 Entity 加载在由 mlcache 库创建的 L1+L2 两级缓存 <code>core_cache</code> 中。</p>
<p>而 consumers 加载到同为 mlcache 创建的不同名的 <code>cache</code> 中。</p>
<h2 id=8-请求生命周期>8. 请求生命周期</h2>
<p>本节讲述一个请求经过 Kong 处理的流程。</p>
<h3 id=81-ssl_certificate_by_lua-阶段>8.1. ssl_certificate_by_lua 阶段</h3>
<pre><code class=language-lua>local function execute()
  local sn, err = server_name()
  if err then
    log(ERR, &quot;could not retrieve SNI: &quot;, err)
    return ngx.exit(ngx.ERROR)
  end

  local cert_and_key, err = find_certificate(sn)
  if err then
    log(ERR, err)
    return ngx.exit(ngx.ERROR)
  end

  if cert_and_key == default_cert_and_key then
    -- use (already set) fallback certificate
    return
  end

  -- set the certificate for this connection

  local ok, err = clear_certs()
  if not ok then
    log(ERR, &quot;could not clear existing (default) certificates: &quot;, err)
    return ngx.exit(ngx.ERROR)
  end

  ok, err = set_cert(cert_and_key.cert)
  if not ok then
    log(ERR, &quot;could not set configured certificate: &quot;, err)
    return ngx.exit(ngx.ERROR)
  end

  ok, err = set_priv_key(cert_and_key.key)
  if not ok then
    log(ERR, &quot;could not set configured private key: &quot;, err)
    return ngx.exit(ngx.ERROR)
  end
end
</code></pre>
<p>根据 Server Name 查找对应 SSL 证书 Cert 和私钥并设置在 Nginx 上。</p>
<h3 id=82-rewrite_by_lua-阶段>8.2. rewrite_by_lua 阶段</h3>
<pre><code class=language-lua>  local ctx = ngx.ctx
  if not ctx.KONG_PROCESSING_START then
    ctx.KONG_PROCESSING_START = ngx.req.start_time() * 1000
  end

  if not ctx.KONG_REWRITE_START then
    ctx.KONG_REWRITE_START = get_now_ms()
  end

  kong_global.set_phase(kong, PHASES.rewrite)
  kong_resty_ctx.stash_ref()

  local is_https = var.https == &quot;on&quot;
  if not is_https then
    log_init_worker_errors(ctx)
  end

  runloop.rewrite.before(ctx)

...

  rewrite = {
    before = function(ctx)
      ctx.host_port = HOST_PORTS[var.server_port] or var.server_port

      -- special handling for proxy-authorization and te headers in case
      -- the plugin(s) want to specify them (store the original)
      ctx.http_proxy_authorization = var.http_proxy_authorization
      ctx.http_te                  = var.http_te
    end,
  },
</code></pre>
<p>初始化 <code>kong.ctx</code> 生命周期 Context，为 Context 添加请求信息。</p>
<h3 id=83-access_by_lua-阶段>8.3. access_by_lua 阶段</h3>
<h4 id=831-路由匹配>8.3.1. 路由匹配</h4>
<p><code>runloop.access.before</code> 会进行调用 <code>Router</code> 实例进行路由匹配。首先会调用 <code>get_updated_router()</code> 判断是否有路由更新，没有则返回当前 <code>Router</code> 实例。</p>
<pre><code class=language-lua>      -- routing request
      local router = get_updated_router()
	  -- 调用 Router.exec() 查找匹配的路由
      local match_t = router.exec()
      if not match_t then
        return kong.response.exit(404, { message = &quot;no Route matched with those values&quot; })
      end
</code></pre>
<p><code>Router.exec()</code> 方法最终会调用 <code>Router.find_route()</code> 方法，该方法接收请求头字段，并生成路由 Cache Key，查找对应的项目。</p>
<pre><code class=language-lua>  local function find_route(req_method, req_uri, req_host, req_scheme,
                            src_ip, src_port,
                            dst_ip, dst_port,
                            sni, req_headers)

    req_method = req_method or &quot;&quot;
    req_uri = req_uri or &quot;&quot;
    req_host = req_host or &quot;&quot;
    req_headers = req_headers or EMPTY_T

    ctx.req_method     = req_method
    ctx.req_uri        = req_uri
    ctx.req_host       = req_host
    ctx.req_headers    = req_headers
    ctx.src_ip         = src_ip or &quot;&quot;
    ctx.src_port       = src_port or &quot;&quot;
    ctx.dst_ip         = dst_ip or &quot;&quot;
    ctx.dst_port       = dst_port or &quot;&quot;
    ctx.sni            = sni or &quot;&quot;

    local cache_key = req_method .. &quot;|&quot; .. req_uri .. &quot;|&quot; .. req_host ..
                      &quot;|&quot; .. ctx.src_ip .. &quot;|&quot; .. ctx.src_port ..
                      &quot;|&quot; .. ctx.dst_ip .. &quot;|&quot; .. ctx.dst_port ..
                      &quot;|&quot; .. ctx.sni

    do
      local match_t = cache:get(cache_key)
      if match_t and hits.header_name == nil then
        return match_t
      end
    end
</code></pre>
<p>如果 LRU 缓存中有匹配路由，则直接返回。</p>
<p>否则继续匹配路由，生成匹配项目，并存入缓存中。</p>
<pre><code class=language-lua>              ...
              local match_t     = {
                  route           = matched_route.route,
                  service         = matched_route.service,
                  headers         = matched_route.headers,
                  upstream_url_t  = upstream_url_t,
                  upstream_scheme = upstream_url_t.scheme,
                  upstream_uri    = upstream_uri,
                  upstream_host   = upstream_host,
                  prefix          = request_prefix,
                  matches         = {
                    uri_captures  = matches.uri_captures,
                    uri           = matches.uri,
                    host          = matches.host,
                    headers       = matches.headers,
                    method        = matches.method,
                    src_ip        = matches.src_ip,
                    src_port      = matches.src_port,
                    dst_ip        = matches.dst_ip,
                    dst_port      = matches.dst_port,
                    sni           = matches.sni,
                  }
                }

                if band(matched_route.match_rules, MATCH_RULES.HEADER) == 0 then
                  cache:set(cache_key, match_t)
                end
                ...
</code></pre>
<p>匹配成功后会将关联的 Route 和 Service 写入 <code>ngx.ctx</code> ，在接下来的生命周期中共享。</p>
<h4 id=832-请求调度>8.3.2. 请求调度</h4>
<p><code>runloop.access.after</code> 中根据 Route、Service 等条件解析出后端要请求的 IP、Port、Schema 等参数。</p>
<pre><code class=language-lua>-- looks up a balancer for the target.
-- @param target the table with the target details
-- @param no_create (optional) if true, do not attempt to create
-- (for thorough testing purposes)
-- @return balancer if found, `false` if not found, or nil+error on error
local function get_balancer(target, no_create)
  -- NOTE: only called upon first lookup, so `cache_only` limitations
  -- do not apply here
  local hostname = target.host


  -- first go and find the upstream object, from cache or the db
  local upstream, err = get_upstream_by_name(hostname)
  if upstream == false then
    return false -- no upstream by this name
  end
  if err then
    return nil, err -- there was an error
  end

  local balancer = balancers[upstream.id]
  if not balancer then
    if no_create then
      return nil, &quot;balancer not found&quot;
    else
      log(ERR, &quot;balancer not found for &quot;, upstream.name, &quot;, will create it&quot;)
      return create_balancer(upstream), upstream
    end
  end

  return balancer, upstream
end
</code></pre>
<p><code>get_balancer()</code> 根据 Service 的 Host 返回最终请求的 Target，和负载均衡器。</p>
<pre><code class=language-lua>  local ip, port, hostname, handle
  if balancer then
    -- have to invoke the ring-balancer
    local hstate = run_hook(&quot;balancer:get_peer:pre&quot;, target.host)
    ip, port, hostname, handle = balancer:getPeer(dns_cache_only,
                                          target.balancer_handle,
                                          hash_value)
    run_hook(&quot;balancer:get_peer:post&quot;, hstate)
    if not ip and
      (port == &quot;No peers are available&quot; or port == &quot;Balancer is unhealthy&quot;) then
      return nil, &quot;failure to get a peer from the ring-balancer&quot;, 503
    end
    hostname = hostname or ip
    target.hash_value = hash_value
    target.balancer_handle = handle

  else
    -- have to do a regular DNS lookup
    local try_list
    local hstate = run_hook(&quot;balancer:to_ip:pre&quot;, target.host)
    ip, port, try_list = toip(target.host, target.port, dns_cache_only)
    run_hook(&quot;balancer:to_ip:post&quot;, hstate)
    hostname = target.host
    if not ip then
      log(ERR, &quot;DNS resolution failed: &quot;, port, &quot;. Tried: &quot;, tostring(try_list))
      if port == &quot;dns server error: 3 name error&quot; or
         port == &quot;dns client error: 101 empty record received&quot; then
        return nil, &quot;name resolution failed&quot;, 503
      end
    end
  end
</code></pre>
<p>调用负载均衡器的策略获取 Target 的 IP，或者直接使用 DNS 查询获取 IP 地址，这一步在 2.1.1 中已经提前进行了 DNS 预缓存，这里可以从缓存中读取。</p>
<p>如果 Service Host 直接是 IP 地址，则不执行负载均衡策略。</p>
<pre><code class=language-lua>  -- ip 则直接返回
  if target.type ~= &quot;name&quot; then
    -- it's an ip address (v4 or v6), so nothing we can do...
    target.ip = target.host
    target.port = target.port or 80 -- TODO: remove this fallback value
    target.hostname = target.host
    return true
  end
</code></pre>
<h3 id=84-balancer_by_lua-阶段>8.4. balancer_by_lua 阶段</h3>
<p>使用 <code>ngx.balancer.set_more_tries()</code> 设置错误重试次数，使用 <code>ngx.balancer.get_last_failure()</code> 获取上一次请求错误详情，在错误处理中进行对上游节点进行被动健康检查。</p>
<pre><code class=language-lua>  if balancer_data.try_count &gt; 1 then
    -- only call balancer on retry, first one is done in `runloop.access.after`
    -- which runs in the ACCESS context and hence has less limitations than
    -- this BALANCER context where the retries are executed

    -- record failure data
    local previous_try = tries[balancer_data.try_count - 1]
    previous_try.state, previous_try.code = get_last_failure()

    -- Report HTTP status for health checks
    local balancer = balancer_data.balancer
    if balancer then
      if previous_try.state == &quot;failed&quot; then
        if previous_try.code == 504 then
          balancer.report_timeout(balancer_data.balancer_handle)
        else
          balancer.report_tcp_failure(balancer_data.balancer_handle)
        end

      else
        balancer.report_http_status(balancer_data.balancer_handle,
                                    previous_try.code)
      end
    end

    local ok, err, errcode = balancer_execute(balancer_data)
    if not ok then
      ngx_log(ngx_ERR, &quot;failed to retry the dns/balancer resolver for &quot;,
              tostring(balancer_data.host), &quot;' with: &quot;, tostring(err))

      ctx.KONG_BALANCER_ENDED_AT = get_now_ms()
      ctx.KONG_BALANCER_TIME = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_BALANCER_START
      ctx.KONG_PROXY_LATENCY = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_PROCESSING_START

      return ngx.exit(errcode)
    end

  else
    -- first try, so set the max number of retries
    local retries = balancer_data.retries
    if retries &gt; 0 then
      set_more_tries(retries)
    end
  end
</code></pre>
<p>请求到最终解析的后端服务，使用 <code>ngx.balancer.set_current_peer()</code> 方法设置访问的地址。</p>
<pre><code class=language-lua>  -- set the targets as resolved
  ngx_log(ngx_DEBUG, &quot;setting address (try &quot;, balancer_data.try_count, &quot;): &quot;,
                     balancer_data.ip, &quot;:&quot;, balancer_data.port)
  -- 最终调度的地址
  local ok, err = set_current_peer(balancer_data.ip, balancer_data.port, pool_opts)
  if not ok then
    ngx_log(ngx_ERR, &quot;failed to set the current peer (address: &quot;,
            tostring(balancer_data.ip), &quot; port: &quot;, tostring(balancer_data.port),
            &quot;): &quot;, tostring(err))

    ctx.KONG_BALANCER_ENDED_AT = get_now_ms()
    ctx.KONG_BALANCER_TIME = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_BALANCER_START
    ctx.KONG_PROXY_LATENCY = ctx.KONG_BALANCER_ENDED_AT - ctx.KONG_PROCESSING_START

    return ngx.exit(500)
  end
</code></pre>
<h3 id=85-header_filter_by_lua-阶段>8.5. header_filter_by_lua 阶段</h3>
<p>此阶段在 Kong 接收完上游服务返回的 Header 字段后执行。</p>
<pre><code class=language-lua>      local upstream_status_header = constants.HEADERS.UPSTREAM_STATUS
      if singletons.configuration.enabled_headers[upstream_status_header] then
        header[upstream_status_header] = tonumber(sub(var.upstream_status or &quot;&quot;, -3))
        if not header[upstream_status_header] then
          log(ERR, &quot;failed to set &quot;, upstream_status_header, &quot; header&quot;)
        end
      end

      local hash_cookie = ctx.balancer_data.hash_cookie
      if not hash_cookie then
        return
      end

      local cookie = ck:new()
      local ok, err = cookie:set(hash_cookie)
</code></pre>
<p><code>runloop.header_filter.before</code> 中在返回结果的 header 里加入节点状态，以及判断是否需要加入负载均衡器一致性策略的 Cookie。</p>
<h3 id=86-body_filter_by_lua-阶段>8.6. body_filter_by_lua 阶段</h3>
<p>此阶段在接收上游服务返回的 Body 数据时执行，根据数据大小划分 chunks，此阶段会被执行多次。</p>
<p>在 Openresty 的生命周期里，<code>body_filter_by_lua</code> 中使用 <code>ngx.arg[1]</code> 读取 chunk，使用 <code>ngx.arg[2]</code> 标记 EOF。</p>
<pre><code class=language-lua>  -- 获取到了所有的 body
  if kong.ctx.core.response_body then
    arg[1] = kong.ctx.core.response_body
    arg[2] = true
  end

  if not arg[2] then
    return
  end

  -- 获取到所有的 body 后
  -- 再统计执行时间
  ctx.KONG_BODY_FILTER_ENDED_AT = get_now_ms()
  ctx.KONG_BODY_FILTER_TIME = ctx.KONG_BODY_FILTER_ENDED_AT - ctx.KONG_BODY_FILTER_START

  if ctx.KONG_PROXIED then
    -- time spent receiving the response (header_filter + body_filter)
    -- we could use $upstream_response_time but we need to distinguish the waiting time
    -- from the receiving time in our logging plugins (especially ALF serializer).
    ctx.KONG_RECEIVE_TIME = ctx.KONG_BODY_FILTER_ENDED_AT - (ctx.KONG_HEADER_FILTER_START or
                                                             ctx.KONG_BALANCER_ENDED_AT or
                                                             ctx.KONG_BALANCER_START or
                                                             ctx.KONG_ACCESS_ENDED_AT)
</code></pre>
<h3 id=87-log_by_lua-阶段>8.7. log_by_lua 阶段</h3>
<p>调用 Lua 的垃圾回收器统计 Kong 占用内存情况：</p>
<pre><code class=language-lua>local update_lua_mem
do
  local pid = ngx.worker.pid
  local kong_shm = ngx.shared.kong

  local Lua_MEM_SAMPLE_RATE = 10 -- seconds
  local last = ngx.time()

  local collectgarbage = collectgarbage

  update_lua_mem = function(force)
    local time = ngx.time()

    if force or time - last &gt;= Lua_MEM_SAMPLE_RATE then
      local count = collectgarbage(&quot;count&quot;)

      local ok, err = kong_shm:safe_set(&quot;kong:mem:&quot; .. pid(), count)
      if not ok then
        log(ERR, &quot;could not record Lua VM allocated memory: &quot;, err)
      end

      last = ngx.time()
    end
  end
end
</code></pre>
<p>根据响应结果调用负载均衡器调整上游节点的权重：</p>
<pre><code class=language-lua>      -- If response was produced by an upstream (ie, not by a Kong plugin)
      -- Report HTTP status for health checks
      local balancer_data = ctx.balancer_data
      if balancer_data and balancer_data.balancer_handle then
        local status = ngx.status
        if status == 504 then
          balancer_data.balancer.report_timeout(balancer_data.balancer_handle)
        else
          balancer_data.balancer.report_http_status(
            balancer_data.balancer_handle, status)
        end
        -- release the handle, so the balancer can update its statistics
        balancer_data.balancer_handle:release()
      end
</code></pre>
<h2 id=9-admin-api>9. Admin API</h2>
<p>Kong Admin API 入口：</p>
<pre><code class=language-lua>function Kong.admin_content(options)
  local ctx = ngx.ctx
  if not ctx.workspace then
    ctx.workspace = kong.default_workspace
  end

  return serve_content(&quot;kong.api&quot;, options)
end
</code></pre>
<pre><code class=language-lua>local function serve_content(module, options)

  -- CORS 跨域相关
  header[&quot;Access-Control-Allow-Origin&quot;] = options.allow_origin or &quot;*&quot;

  -- 启动 lapis
  lapis.serve(module)
end
</code></pre>
<p>关于 <a href=https://leafo.net/lapis/>Lapis</a>：</p>
<blockquote>
<p>Lapis is a framework for building web applications using <a href=https://moonscript.org>MoonScript</a> or <a href=https://lua.org>Lua</a> that runs inside of a customized version of <a href=https://nginx.org>Nginx</a> called <a href=https://openresty.org>OpenResty</a>.</p>
</blockquote>
<pre><code class=language-lua># api/init.lua
-- 加载固定路由
-- Load core routes
for _, v in ipairs({&quot;kong&quot;, &quot;health&quot;, &quot;cache&quot;, &quot;config&quot;, &quot;clustering&quot;}) do
  local routes = require(&quot;kong.api.routes.&quot; .. v)
  api_helpers.attach_routes(app, routes)
end

  local routes = {}

  -- DAO Routes
  for _, dao in pairs(singletons.db.daos) do
    if dao.schema.generate_admin_api ~= false and not dao.schema.legacy then
      routes = Endpoints.new(dao.schema, routes)
    end
  end
</code></pre>
<p>初始化构建路由：</p>
<pre><code class=language-lua># api/endpoints.lua
-- 创建基础路由
-- Generates admin api endpoint functions
--
-- Examples:
--
-- /routes
-- /routes/:routes
-- /routes/:routes/service
-- /services/:services/routes
--
-- and
--
-- /services
-- /services/:services
-- /services/:services/routes/:routes
local function generate_endpoints(schema, endpoints)
  -- list 路由
  -- e.g. /routes
  generate_collection_endpoints(endpoints, schema)

  -- 单体路由
  -- e.g. /routes/:routes
  generate_entity_endpoints(endpoints, schema)

  -- 判断是否有关联对象
  -- 例如 route 关联 services
  for foreign_field_name, foreign_field in schema:each_field() do
    -- 外键
    if foreign_field.type == &quot;foreign&quot; and not foreign_field.schema.legacy then
      -- e.g. /routes/:routes/service
      generate_entity_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name, true)

      -- e.g. /services/:services/routes
      generate_collection_endpoints(endpoints, schema, foreign_field.schema, foreign_field_name)

      -- e.g. /services/:services/routes/:routes
      generate_entity_endpoints(endpoints, foreign_field.schema, schema, foreign_field_name)
    end
  end

  return endpoints
end

-- Generates admin api collection endpoint functions
--
-- Examples:
--
-- /routes
-- /services/:services/routes
--
-- and
--
-- /services
local function generate_collection_endpoints(endpoints, schema, foreign_schema, foreign_field_name)
  local collection_path

  -- 外键关联
  if foreign_schema then
    collection_path = fmt(&quot;/%s/:%s/%s&quot;, foreign_schema.admin_api_name or
                                        foreign_schema.name,
                                        foreign_schema.name,
                                        schema.admin_api_nested_name or
                                        schema.admin_api_name or
                                        schema.name)

  else
    -- 没有外键关联
    collection_path = fmt(&quot;/%s&quot;, schema.admin_api_name or
                                 schema.name)
  end

  endpoints[collection_path] = {
    schema  = schema,
    methods = {
      --OPTIONS = method_not_allowed,
      --HEAD    = method_not_allowed,
      GET     = get_collection_endpoint(schema, foreign_schema, foreign_field_name),
      POST    = post_collection_endpoint(schema, foreign_schema, foreign_field_name),
      --PUT     = method_not_allowed,
      --PATCH   = method_not_allowed,
      --DELETE  = method_not_allowed,
    },
  }
end
</code></pre>
<p>只关注 POST 请求处理的部分：</p>
<pre><code class=language-lua>local function post_collection_endpoint(schema, foreign_schema, foreign_field_name, method)
  return function(self, db, helpers, post_process)
    if foreign_schema then
      local foreign_entity, _, err_t = select_entity(self, db, foreign_schema)
      if err_t then
        return handle_error(err_t)
      end

      if not foreign_entity then
        return not_found()
      end

      self.args.post[foreign_field_name] = foreign_schema:extract_pk_values(foreign_entity)
    end

    -- 处理请求，参数校验，插入数据
    local entity, _, err_t = insert_entity(self, db, schema, method)
    if err_t then
      return handle_error(err_t)
    end

    -- 回调函数
    if post_process then
      entity, _, err_t = post_process(entity)
      if err_t then
        return handle_error(err_t)
      end
    end

    return created(entity)
  end
end
</code></pre>
<p>Admin API 仅仅是一层 API 封装，不负责背后的事件处理和数据同步，背后的事件处理在文章事件处理部分阐述过了。</p>
<h2 id=10-插件开发>10. 插件开发</h2>
<p>简单介绍一下插件开发能用上的一些小 Trick。</p>
<h3 id=101-多层-schema-嵌套>10.1. 多层 Schema 嵌套</h3>
<p>看着很恶心吧，但这是多层 Schema 嵌套的样子。</p>
<pre><code class=language-lua>local schema = {
    name = plugin_name,
    fields = {
        { consumer = typedefs.no_consumer },
        { protocols = typedefs.protocols_http },
        { config = {
          type = &quot;record&quot;,
          fields = { {
            rules = {
              type = &quot;array&quot;,
              elements = {
                type = &quot;record&quot;,
                fields = { {
                  match = {
                    type = &quot;array&quot;,
                    elements = {
                      type = &quot;record&quot;,
                      fields = {
                        { vars = { type = &quot;array&quot;, elements = {
                            type = &quot;array&quot;,
                            elements = { type = &quot;string&quot; }
                        } } }
                      }
                    }
                  }
                } }
              }
            }
          } },
        } }
    }
}
</code></pre>
<h3 id=102-自定义-schema-校验器>10.2. 自定义 Schema 校验器</h3>
<pre><code class=language-lua>local expr = require(&quot;resty.expr.v1&quot;)

local schema_validator = function(conf)
    if conf.rules then
        for _, rule in ipairs(conf.rules) do
            if rule.match and type(rule.match) == &quot;table&quot; then
                for _, m in pairs(rule.match) do
                    local ok, err = expr.new(m.vars)
                    if not ok then
                        return false, &quot;failed to validate the 'vars' expression: &quot; .. err
                    end
                end
            end
        end
    end

    return true
end
</code></pre>
<h3 id=103-日志打印-table>10.3. 日志打印 Table</h3>
<pre><code class=language-lua>kong.log.inspect.on()
kong.log.debug(&quot;Lua table: &quot;, t)
</code></pre>
<h3 id=104-自定义日志输出>10.4. 自定义日志输出</h3>
<p>2.3.0 版本以上可用。</p>
<pre><code class=language-lua>local entry = {
    entries = ctx.log_entries,
    id = self.transaction_id,
    action = action_name,
}

kong.log.set_serialize_value(&quot;waf&quot;, entry)
</code></pre>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p><a href=https://github.com/Kong/kong>🦍 The Cloud-Native API Gateway</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<div class=post-meta>
<time datetime=" 2021-09-21" itemprop=datePublished>Sep 21, 2021</time>
</div>
</footer>
</article>
<script src=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.min.js></script>
<aside class=typeface-sans lang=zh-hans>
<nav class=toc></nav>
</aside>
<script>tocbot.init({tocSelector:'.toc',contentSelector:'article',headingSelector:'h1, h2, h3, h4, h5',hasInnerContainers:!0,collapseDepth:"3",positionFixedSelector:".toc",headingsOffset:10})</script>
</div><script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/filter-highlight-all/prism-filter-highlight-all.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script>Prism.plugins.filterHighlightAll.add(function(a){return a.language!=="mermaid"})</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.init({startOnLoad:!0},"pre code.language-mermaid",function(){const a=document.querySelectorAll('code.language-mermaid');for(const c of a){c.style.backgroundColor='initial';const b=c.parentNode;b.style.border='none',b.style.textAlign='center',window.darkmode&&!window.darkmode.isActivated()&&(b.style.backgroundColor='initial')}})</script>
</div>
</main><footer class=site-footer>
<div class=wrapper>
<div class=social-links>
<a class="social-link social-github" href=https://github.com/mayocream><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5C9.34 21.58 9.5 21.27 9.5 21 9.5 20.77 9.5 20.14 9.5 19.31 6.73 19.91 6.14 17.97 6.14 17.97c-.46-1.16-1.11-1.47-1.11-1.47C4.12 15.88 5.1 15.9 5.1 15.9 6.1 15.97 6.63 16.93 6.63 16.93 7.5 18.45 8.97 18 9.54 17.76 9.63 17.11 9.89 16.67 10.17 16.42c-2.22-.25-4.55-1.11-4.55-4.92.0-1.11.38-2 1.03-2.71C6.55 8.54 6.2 7.5 6.75 6.15c0 0 .84-.27 2.75 1.02C10.29 6.95 11.15 6.84 12 6.84s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02C17.8 7.5 17.45 8.54 17.35 8.79 18 9.5 18.38 10.39 18.38 11.5c0 3.82-2.34 4.66-4.57 4.91C14.17 16.72 14.5 17.33 14.5 18.26c0 1.34.0 2.42.0 2.74.0.27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg>
</a>
<a class="social-link social-rss" href=/index.xml target=_blank><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M6.18 15.64a2.18 2.18.0 012.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18.0 012.18-2.18M4 4.44A15.56 15.56.0 0119.56 20H16.73A12.73 12.73.0 004 7.27V4.44M4 10.1A9.9 9.9.0 0113.9 20H11.07A7.07 7.07.0 004 12.93V10.1z"/></svg>
</a>
</div>
<div class=credits>
Theme KAGAMI by Kamikat
</div>
</div>
</footer><script>(function(a){for(var a=Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')),b=0,c;b!=a.length;b++)c=a[b],c.innerHTML=c.innerHTML.replace(/[\u2000-\u206e⸀-\u2e7e⺀-\u2efe⼀-\u2fde⿰-\u2ffe\u3000-〾\u3040-ゞ゠-ヾ\u3100-\u312e\u3130-ㆎ㆐-㆞ㆠ-\u31be㇀-\u31eeㇰ-ㇾ㈀-㋾㌀-㏾㐀-\u4dbe一-\u9ffe\ua960-\ua97e가-\ud7ae\ud7b0-\ud7fe豈-\ufafe︰-﹎\uff00-￮]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud82c[\udc00-\udcfe]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e]/g,function(a){return'<span class="baseline-fix-block">'+a+'<'+'/span>'}),c.classList.remove('baseline-fix')})(Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')))</script>
<script type=text/javascript>const resize=function(){this.width=.5*(this.naturalWidth||this.width)};Array.prototype.forEach.call(document.querySelectorAll('.half-size, .retina2x'),function(a){a.naturalWidth?resize.call(a):a.onload=resize})</script>
<script src=https://cdn.jsdelivr.net/npm/twemoji@13.1.0/dist/twemoji.min.js></script>
<script>twemoji.parse(document.body,{folder:'svg',ext:'.svg'})</script>
</body>