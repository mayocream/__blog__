<!doctype html><html lang=zh-hans><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>WAF 源码分析 - Mayo's Blog</title>
<meta name=description content="源码分析主要针对规则引擎部分进行解析，以更好地理解 WAF 规则的加载和执行过程，平台设计时能够有更丰富的思考。未阅读的源码部分还包含 Perl 脚本对 ModSecurity 规则">
<meta name=author content>
<link rel=preconnect href=https://cdn.jsdelivr.net>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,700|Press+Start+2P" rel=stylesheet>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300;400&family=Noto+Sans+JP:wght@300;400&family=Noto+Sans+SC:wght@300;400&family=Noto+Serif:wght@300;400&family=Noto+Serif+JP:wght@300;400&family=Noto+Serif+SC:wght@300;400&family=Source+Code+Pro:wght@300;400" rel=stylesheet>
<link rel=stylesheet href="/bundle.css?v=1636177403" media=all>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.css>
<link rel=icon href=https://github.com/mayocream.png><meta name=generator content="Hugo 0.88.1">
<link rel=canonical href=https://shoujo.ink/2021/11/waf-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-JKVXF5HSKT','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="WAF 源码分析">
<meta property="og:description" content="源码分析主要针对规则引擎部分进行解析，以更好地理解 WAF 规则的加载和执行过程，平台设计时能够有更丰富的思考。未阅读的源码部分还包含 Perl 脚本对 ModSecurity 规则">
<meta property="og:type" content="article">
<meta property="og:url" content="https://shoujo.ink/2021/11/waf-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-06T13:40:00+08:00">
<meta property="article:modified_time" content="2021-11-06T13:40:00+08:00"><meta property="og:site_name" content="Mayo's Blog">
</head>
</html>
<body><script src=https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js></script>
<script>const opts={bottom:'32px',right:'unset',left:'32px',time:'0.3s',mixColor:'#fff',backgroundColor:'#fff',buttonColorDark:'#100f2c',buttonColorLight:'#fff',saveInCookies:!0,label:'🌓',autoMatchOsTheme:!0};let darkmode;window.matchMedia('only screen and (min-width: 680px)').matches?(darkmode=new Darkmode(opts),darkmode.showWidget()):(localStorage.removeItem('darkmode'),darkmode=new Darkmode(opts)),window.darkmode=darkmode,document.addEventListener('DOMContentLoaded',function(){document.body.style.opacity=1})</script>
<main class=page-content aria-label=Content>
<div class=wrapper><nav class=site-nav>
<a class=page-link href=/posts/>Posts</a>
<a class=page-link href=/about/>About</a>
</nav><header class=post-header>
<a class=site-title href=https://shoujo.ink>Mayo's Blog</a>
<h1 class="post-title baseline-fix typeface-sans" lang=zh-hans itemprop="name headline">WAF 源码分析</h1>
</header>
<div class=post-cover aria-label=Cover>
<div class=post-cover-wrapper>
<img src alt>
</div>
<div class=cover-meta></div>
</div>
<div class=post-layout>
<article class="post typeface-sans" lang=zh-hans itemscope itemtype=http://schema.org/BlogPosting>
<div class=post-content itemprop=articleBody>
<blockquote>
<p>源码分析主要针对规则引擎部分进行解析，以更好地理解 WAF 规则的加载和执行过程，平台设计时能够有更丰富的思考。未阅读的源码部分还包含 Perl 脚本对 ModSecurity 规则转换和 Test::Nginx 单元测试部分。</p>
</blockquote>
<h2 id=1-规则引擎>1. 规则引擎</h2>
<p>应用网络防火墙（WAF）的核心是规则引擎，规则引擎实现了规则集的编排、计算，基于规则集能够实现丰富的拦截策略。</p>
<p>商业 WAF 产品的规则集包含：</p>
<ol>
<li><strong>OWASP ModSecurity 核心规则集</strong></li>
<li><strong>平台托管规则集</strong></li>
<li><strong>用户自定义规则</strong></li>
</ol>
<h3 id=11-规则集>1.1. 规则集</h3>
<h4 id=111-owasp-modsecurity-核心规则集>1.1.1. OWASP ModSecurity 核心规则集</h4>
<blockquote>
<p>OWASP ModSecurity 核心规则集包含来自于 OWASP 项目的若干规则。平台不编写或管理 OWASP 规则。</p>
</blockquote>
<p><strong>OWASP ModSecurity 核心规则集</strong>根据触发的 OWASP 规则数量为每个请求指定一个分数。某些 OWASP 规则的敏感度分数高于其他规则。在 OWASP 评估请求后，Cloudflare 会将最终分数与为该域名配置的<strong>危险阈值</strong>进行比较。如果分数超过<strong>危险阈值</strong>，则根据 <strong>OWASP ModSecurity 核心规则集</strong>中配置的<strong>操作</strong>来处理这个请求。</p>
<ul>
<li>阻止 - 请求被丢弃。</li>
<li>记录 - 放行请求，只记录审计日志。</li>
</ul>
<p>对于具体的<strong>危险阈值</strong>，触发 WAF 所需的敏感度得分如下：</p>
<ul>
<li>低 - 60 及以上</li>
<li>中 - 40 及以上</li>
<li>高 - 25 及以上</li>
</ul>
<p>
<figure class=image>
<img src=/2021/11/waf-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6db60e1d-1a01-4fa6-95d0-f977c72acd90/Untitled.png alt=img loading=lazy>
<figcaption>img</figcaption>
</figure></p>
<h4 id=112-平台托管规则集>1.1.2. 平台托管规则集</h4>
<blockquote>
<p>平台托管规则集包含由平台方编写和管理的安全规则。</p>
</blockquote>
<p>针对 MSP 平台托管的服务大多数为前后端分离，API 调用的模式，针对平台服务定制。</p>
<p><strong>托管规则集</strong>内各条规则可用的<strong>模式</strong>包括：</p>
<ul>
<li>默认 - 采取查看具体规则时列在下的默认操作。</li>
<li>禁用 - 不启用规则集。</li>
<li>阻止 - 请求被丢弃。</li>
<li>记录 - 放行请求，只记录审计日志。</li>
</ul>
<h4 id=113-用户自定义规则集>1.1.3. 用户自定义规则集</h4>
<p>允许用户对于路由级别启用 WAF 功能，设定自定义的 WAF 规则。</p>
<p>使用通用的 WAF 设置语法，平台提供统一的界面可视化操作。</p>
<p>
<figure class=image>
<img src=/2021/11/waf-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/28dde025-7113-42f0-ac31-0bced664f089/Untitled.png alt=img loading=lazy>
<figcaption>img</figcaption>
</figure></p>
<h3 id=12-规则编写>1.2. 规则编写</h3>
<p>置于 Kong 网关的 WAF 模块是基于 Lua 脚本（lua-resty-core）结合 C 模块 FFI 调用的高性能 WAF 库二次开发的。</p>
<p>其内置的规则引擎使用 JSON 编写，提供多种灵活的操作和组合。</p>
<h4 id=121-规则示例>1.2.1. 规则示例</h4>
<pre><code class=language-json>{
   // 表示在 Nginx 中请求的 Access 阶段运行
   &quot;access&quot; : [ // 规则集使用数组, 按顺序编排
      {
         // 操作类型
         &quot;actions&quot; : {
            &quot;disrupt&quot; : &quot;CHAIN&quot; // 链式条件组合, 本身不执行任何动作
         },
         &quot;id&quot; : 11001, // 规则的 ID, 会在审计日志中使用
         &quot;msg&quot; : &quot;Ignore passive requests with no arguments&quot;, // 规则的描述
         &quot;operator&quot; : &quot;REFIND&quot;, // 规则的运算符，REFIND 代表 ngx.re.find, 通俗来说是 Match 运算
         &quot;opts&quot; : {
            &quot;nolog&quot; : true // 不记录日志
         },
         &quot;pattern&quot; : &quot;^(?:GET|HEAD)$&quot;, // 匹配值的正则表达式, 匹配 GET 或 HEAD
         &quot;vars&quot; : [ 
            {
               &quot;type&quot; : &quot;METHOD&quot; // 匹配请求的字段名, 这里为 HTTP Method
            }
         ]
      },
      {
         &quot;actions&quot; : {
            &quot;disrupt&quot; : &quot;ACCEPT&quot; // 操作类型为允许
         },
         &quot;id&quot; : 11002,
         &quot;msg&quot; : &quot;Ignore passive requests with no arguments&quot;,
         &quot;op_negated&quot; : 1, // 表示取反, 即不等于
         &quot;operator&quot; : &quot;REFIND&quot;,
         &quot;opts&quot; : {
            &quot;nolog&quot; : true // 不记录日志
         },
         &quot;pattern&quot; : &quot;.*&quot;, // 匹配任何值
         &quot;vars&quot; : [
            {
               &quot;parse&quot; : [ // 表示解析所有字符串
                  &quot;all&quot;,
                  1
               ],
               &quot;type&quot; : &quot;REQUEST_ARGS&quot; // 匹配请求的字段, 这里为 URI 查询字符串
            }
         ]
      }
   ]
}
</code></pre>
<p>上述的示例规则表示：当传入的请求 “HTTP 请求方法” <em>正则匹配</em> <code>^(GET/HEAD)$</code> ，且 &ldquo;URI 查询字符串&rdquo; 为空时，<em>允许</em> 该请求。</p>
<h4 id=122-规则处理概述>1.2.2. 规则处理概述</h4>
<p>
<figure class=image>
<img src=/2021/11/waf-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14fa86e6-413f-45b4-9b5a-cb9e5000a44d/Untitled.png alt=规则解析 loading=lazy>
<figcaption>规则解析</figcaption>
</figure></p>
<h3 id=13-规则编排>1.3. 规则编排</h3>
<p>规则编排在 lua-resty-waf 中称作 <em><strong>规则预处理</strong></em>，在 <code>rule_calc.lua</code> 文件中，主要的行为包含：</p>
<ol>
<li>规则主键条目唯一 KEY 构建</li>
<li>规则组构建（索引优化）</li>
</ol>
<h4 id=131-规则主键计算>1.3.1. 规则主键计算</h4>
<p>为每一行规则生成 KEY，作为缓存 KEY 使用。</p>
<p>将规则中 Lua Table 平铺为 String。</p>
<pre><code class=language-lua>-- 生成 transform 的 KEY
local function _transform_collection_key(transform)
	if not transform then
		return nil
	end

	if type(transform) ~= 'table' then
		return tostring(transform)
	else
		return table_concat(transform, ',')
	end
end

-- 计算规则主键 (KEY)
local function _build_collection_key(var, transform)
	local key = {}
	-- TYPE 为规则查询的变量名
	key[1] = tostring(var.type)

	if var.parse ~= nil then
		table_insert(key, tostring(var.parse[1]))
		table_insert(key, tostring(var.parse[2]))
	end

	if var.ignore ~= nil then
		table_insert(key, tostring(_ignore_collection_key(var.ignore)))
	end

	table_insert(key, tostring(_transform_collection_key(transform)))

	return table_concat(key, &quot;|&quot;)
end
</code></pre>
<p><code>transform</code> 缓存在 Lua Table，规则主键作为 KEY 快速查找。</p>
<pre><code class=language-lua>local function _build_collection(self, rule, var, collections, ctx, opts)
    ...

	-- 规则主键
	local collection_key = var.collection_key
	local collection

	--_LOG_&quot;Checking for collection_key &quot; .. collection_key

	if not var.storage and not ctx.transform_key[collection_key] then
		--_LOG_&quot;Collection cache miss&quot;
		-- 获取规则需要的所有数据
		-- 单个值或者数组
		collection = _parse_collection(self, collections[var.type], var)

		-- 对数据集进行转换
		if opts.transform then
			collection = _do_transform(self, collection, opts.transform)
		end

		-- Lua table 缓存已转换的数据集
		ctx.transform[collection_key]     = collection
		ctx.transform_key[collection_key] = true
	elseif var.storage then
		--_LOG_&quot;Forcing cache miss&quot;
		collection = _parse_collection(self, collections[var.type], var)
	else
		--_LOG_&quot;Collection cache hit!&quot;
		collection = ctx.transform[collection_key]
	end

    ...

	return collection
end
</code></pre>
<h4 id=132-规则预处理>1.3.2. 规则预处理</h4>
<p>规则引擎对于规则匹配是遍历操作，预处理中为规则匹配成功或失败的后续行为做出判断，在规则条目中增加 <code>offset_match</code> 和 <code>offset_nomatch</code> 两个值。</p>
<pre><code class=language-lua>-- 添加链规则 offset 
-- 接收参数  [规则链, 总规则数, 规则链起始 index]
local function _write_chain_offsets(chain, max, cur_offset)
	-- 规则链长度
	local chain_length = #chain
	-- 倒叙遍历 index
	local offset = chain_length

	-- 遍历规则
	for i = 1, chain_length do
		local rule = chain[i]

		-- 当前 chain 是否在最末尾
		if offset + cur_offset &gt;= max then -- TODO 这个表达式可以简化
			rule.offset_nomatch = nil -- 默认, 没有下一条规则链了
			if rule.actions.disrupt == &quot;CHAIN&quot; then
				rule.offset_match = 1 -- 下次执行增加 1
			else
				rule.offset_match = nil -- 没有下一条规则链了
			end
		else
			rule.offset_nomatch = offset -- 跳过当前的剩余规则, 执行下一组规则
			rule.offset_match = 1
		end

		cur_offset = cur_offset + 1
		offset = offset - 1
	end
end
</code></pre>
<p>在规则遍历时，引擎会根据规则的 <code>offset</code> 决定下一行规则的索引，跳过不必要的规则执行，提升效率。</p>
<pre><code class=language-lua>-- 规则集编排
function _M.calculate(ruleset, meta_lookup)
	-- 规则条目数
	local max = #ruleset
	-- 储存一条规则链
	local chain = {}

	-- 遍历规则集
	for i = 1, max do
		-- 单条规则
		local rule = ruleset[i]

		-- 是否有单独的配置项
		if not rule.opts then rule.opts = {} end

		-- 储存当前规则链
		chain[#chain + 1] = rule

		-- VAR 通常只有一个元素
		for i in ipairs(rule.vars) do
			local var = rule.vars[i]
			-- 计算规则主键
			var.collection_key = _build_collection_key(var, rule.opts.transform)
		end

		-- 规则的动作非 CHAIN, 可能是 [ACCEPT,DENY,DROP,IGNORE]
		if rule.actions.disrupt ~= &quot;CHAIN&quot; then
			-- 计算规则链增加的 step
			-- 传入参数 [规则链, 总规则数, 规则链起始 index]
			_write_chain_offsets(chain, max, i - #chain)

			if rule.skip then
				-- 跳过一组规则
				_write_skip_offset(rule, max, i)
			elseif rule.skip_after then
				...
			end

			-- 跳出当前规则链
			chain = {}
		end

		...
	end
end
</code></pre>
<p>示意图：</p>
<p>
<figure class=image>
<img src=/2021/11/waf-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/images/image-20210813182139716.png alt=image-20210813182139716 loading=lazy>
<figcaption>image-20210813182139716</figcaption>
</figure></p>
<h3 id=14-数据绑定>1.4. 数据绑定</h3>
<h4 id=141-数据集构建>1.4.1. 数据集构建</h4>
<p>规则引擎在每次处理请求时，都要进行数据集的构建，数据集包含了 Nginx 请求的基本信息，例如 HTTP Header，URI，URI 查询字符串等。</p>
<p>规则引擎会根据每个执行阶段（Phase）加载对于的环境变量。</p>
<pre><code class=language-lua>-- 规则解析, 数据绑定, TODO 只加载必要的数据
_M.lookup = {
	access = function(waf, collections, ctx)
		local request_headers     = ngx.req.get_headers()
		local request_var         = ngx.var.request
		local request_method      = ngx.req.get_method()
		local request_uri_args    = ngx.req.get_uri_args()
		local request_uri         = request.request_uri()
		local request_uri_raw     = request.request_uri_raw(request_var, request_method)
		local request_basename    = request.basename(waf, ngx.var.uri)
		local request_body        = request.parse_request_body(waf, request_headers, collections)
		local request_cookies     = request.cookies() or {}
		local request_common_args = request.common_args({ request_uri_args, request_body, request_cookies })
		local query_string        = ngx.var.query_string

		local query_str_size = query_string and #query_string or 0
		local body_size = ngx.var.http_content_length and tonumber(ngx.var.http_content_length) or 0

		collections.REMOTE_ADDR       = ngx.var.remote_addr
		collections.HTTP_VERSION      = ngx.req.http_version()
		collections.METHOD            = request_method
		collections.URI               = ngx.var.uri
		collections.URI_ARGS          = request_uri_args
		collections.QUERY_STRING      = query_string
		collections.REQUEST_URI       = request_uri
		collections.REQUEST_URI_RAW   = request_uri_raw
		collections.REQUEST_BASENAME  = request_basename
		collections.REQUEST_HEADERS   = request_headers
		collections.COOKIES           = request_cookies
		collections.REQUEST_BODY      = request_body
		collections.REQUEST_ARGS      = request_common_args
		collections.REQUEST_LINE      = request_var
		collections.PROTOCOL          = ngx.var.server_protocol
		collections.TX                = ctx.storage[&quot;TX&quot;]
		collections.NGX_VAR           = ngx.var
		collections.MATCHED_VARS      = {}
		collections.MATCHED_VAR_NAMES = {}
		collections.SCORE_THRESHOLD   = waf._score_threshold -- 危险阈值
        ...
	end,
	header_filter = function(waf, collections)
		local response_headers = ngx.resp.get_headers()

		collections.RESPONSE_HEADERS = response_headers
		collections.STATUS           = ngx.status
	end,
	body_filter = function(waf, collections, ctx)
		...
	end,
	log = function() end
}
</code></pre>
<h4 id=142-数据转换>1.4.2. 数据转换</h4>
<p>WAF 的规则中通常会提供多种常用的运算函数，例如 <code>tonumber()</code>, <code>lowercase()</code> 等，也会提供常规变量使用，例如 <code>${geo_ip}</code> 。</p>
<p>规则引擎需要对其进行转换，动态解析出真实的变量，以便后续进行运算操作。</p>
<p>项目提供的常用的 <em>转换函数</em> 有：</p>
<pre><code class=language-lua>_M.lookup = {
	base64_decode = function(waf, value)
		--_LOG_&quot;Decoding from base64: &quot; .. tostring(value)
		-- 使用 lua-resty-core 解码 base64
		local t_val = ngx.decode_base64(tostring(value))
		if t_val then
			--_LOG_&quot;Decode successful, decoded value is &quot; .. t_val
			return t_val
		else
			--_LOG_&quot;Decode unsuccessful, returning original value &quot; .. value
			return value
		end
	end,
	base64_encode = function(waf, value)
		--_LOG_&quot;Encoding to base64: &quot; .. tostring(value)
		local t_val = ngx.encode_base64(value)
		--_LOG_&quot;Encoded value is &quot; .. t_val
		return t_val
	end,
	-- 替换空白字符, 正则匹配将多个空格字符 (空格/tab) 转换为单个空格
	compress_whitespace = function(waf, value)
		return ngx.re.gsub(value, [=[\s+]=], ' ', waf._pcre_flags)
	end,
	-- htmlentities 包, 针对 API 较多的情况应该避免解析 HTML
	html_decode = function(waf, value)
		local str = hdec.decode(value)
		--_LOG_&quot;html decoded value is &quot; .. str
		return str
	end,
	-- [经常使用]
	lowercase = function(waf, value)
		return string_lower(tostring(value))
	end,
	
    --- 此处省略不常用的转换函数...
    
	-- [经常使用]
	uri_decode = function(waf, value)
		return ngx.unescape_uri(value)
	end,
}
</code></pre>
<p>对数据集进行转换，输出转换后的数据集：</p>
<pre><code class=language-lua>-- transform collection values based on rule opts
local function _do_transform(self, collection, transform)
	local t = {}

	-- transform 函数可能是数组
	if type(transform) == &quot;table&quot; then
		t = collection

		for k, v in ipairs(transform) do
			-- 对数据集执行转换函数
			t = _do_transform(self, t, transform[k])
		end
	else
		-- 执行单个转换函数，递归执行
		if type(collection) == &quot;table&quot; then
			for k, v in pairs(collection) do
				t[k] = _do_transform(self, collection[k], transform)
			end
		else
			if not collection then
				return collection
			end

			return transform_t.lookup[transform](self, collection)
		end
	end

	return t
end
</code></pre>
<p>在规则处理中动态解析变量：</p>
<pre><code class=language-lua>-- 动态获取要对比的值
if opts.parsepattern then
    --_LOG_&quot;Parsing dynamic pattern: &quot; .. pattern
    pattern = util.parse_dynamic_value(self, pattern, collections)
end
</code></pre>
<p>从数据集中动态获取变量：</p>
<pre><code class=language-lua>-- pick out dynamic data from storage key definitions
function _M.parse_dynamic_value(waf, key, collections)
	local lookup = function(macro)
		local val, specific
		-- cheat on the start index
		local dot = string_find(macro, &quot;%.&quot;, 5)
		if dot then
			val = string_sub(macro, 3, dot - 1)
			specific = string_sub(macro, dot + 1, -2)
		else
			val = string_sub(macro, 3, -2)
		end

		local lval = collections[val]

		if type(lval) == &quot;table&quot; then
			if specific then
				return lval[specific] and tostring(lval[specific]) or
					tostring(lval[string.lower(specific)])
			else
				return val
			end
		else
			return lval
		end
	end

	local str = string_gsub(key, &quot;%%%b{}&quot;, lookup)

	--_LOG_&quot;Parsed dynamic value is &quot; .. str

	return tonumber(str) and tonumber(str) or str
end
</code></pre>
<h3 id=15-规则运算>1.5. 规则运算</h3>
<p>WAF 规则运算符通常包含 <em>等于、不等于、包含、不包含、正则匹配</em> 等符号。</p>
<p>规则引擎具体通过 lua-resty-core、lua-nginx-module、Lua JIT 提供的方法进行数据比较，该项目中也用到了第三方库，有用作字符串多模式匹配的 <a href=https://github.com/cloudflare/lua-aho-corasick/>AC 自动机 Lua FFI 库</a>（C 实现），和检测 SQL 注入和 XSS 的 <a href=https://github.com/client9/libinjection>libinjection</a> 库（C 实现）。</p>
<p>较为常用的有正则匹配的 <code>ngx.re.match</code> 和 <code>ngx.re.find</code> 函数，两者都用了 PCRE 优化的参数 <code>jio</code>，表示编译结果缓存、启用 Lua JIT 优化、大小写不敏感，后者相比 match 函数，只返回匹配字符串的索引，更为高效。</p>
<pre><code class=language-lua>-- match 正则匹配
---@return boolean, string[] 
function _M.regex(waf, subject, pattern)
	-- Lua JIT 优化参数
	local opts = waf._pcre_flags
	local captures, err, match

	if type(subject) == &quot;table&quot; then
		for _, v in ipairs(subject) do
			match, captures = _M.regex(waf, v, pattern)

			if match then
				break
			end
		end
	else
		captures, err = ngx.re.match(subject, pattern, opts)

		if err then
			logger.warn(waf, &quot;error in ngx.re.match: &quot; .. err)
		end

		if captures then
			match = true
		end
	end

	return match, captures
end

-- 正则匹配 ngx.re.find, 只返回匹配字符串的 index
---@return boolean, number
function _M.refind(waf, subject, pattern)
	local opts = waf._pcre_flags
	local from, to, err, match

	if type(subject) == &quot;table&quot; then
		for _, v in ipairs(subject) do
			match, from = _M.refind(waf, v, pattern)

			if match then
				break
			end
		end
	else
		from, to, err = ngx.re.find(subject, pattern, opts)

		if err then
			logger.warn(waf, &quot;error in ngx.re.find: &quot; .. err)
		end

		if from then
			match = true
		end
	end

	return match, from
end
</code></pre>
<p>AC 自动机进行字符串匹配，首先创建 Trie 前缀树和 Fail 指针，构建结果缓存在 Lua Table 中，避免重复创建的性能损耗，在项目示例规则集中，主要用于 user-agent 的匹配。</p>
<pre><code class=language-lua>
-- AC 自动机字符串查找
---@return boolean, string
function _M.ac_lookup(needle, haystack, ctx)
	local id = ctx.id
	local match, _ac, value

	-- dictionary creation is expensive, so we use the id of
	-- the rule as the key to cache the created dictionary
	-- 使用 Lua Table 缓存字典
	if not _ac_dicts[id] then
		_ac = ac.create_ac(haystack)
		_ac_dicts[id] = _ac
	else
		_ac = _ac_dicts[id]
	end

	if type(needle) == &quot;table&quot; then
		for _, v in ipairs(needle) do
			match, value = _M.ac_lookup(v, haystack, ctx)

			if match then
				break
			end
		end
	else
		match = ac.match(_ac, needle)

		if match then
			match = true
			value = needle
		end
	end

	return match, value
end
</code></pre>
<p>常用的规则运算符如下，返回 <em>是否匹配成功，匹配的结果</em>。</p>
<pre><code class=language-lua>-- 操作符
-- 接收参数 [waf 实例, 数据集, 匹配参数]
---@return boolean, string|number
_M.lookup = {
	REGEX        = function(waf, collection, pattern) return _M.regex(waf, collection, pattern) end,
	REFIND       = function(waf, collection, pattern) return _M.refind(waf, collection, pattern) end,
	EQUALS       = function(waf, collection, pattern) return _M.equals(collection, pattern) end,
	GREATER      = function(waf, collection, pattern) return _M.greater(collection, pattern) end,
	LESS         = function(waf, collection, pattern) return _M.less(collection, pattern) end,
	GREATER_EQ   = function(waf, collection, pattern) return _M.greater_equals(collection, pattern) end,
	LESS_EQ      = function(waf, collection, pattern) return _M.less_equals(collection, pattern) end,
	EXISTS       = function(waf, collection, pattern) return _M.exists(collection, pattern) end,
	CONTAINS     = function(waf, collection, pattern) return _M.contains(collection, pattern) end,
	STR_EXISTS   = function(waf, collection, pattern) return _M.str_find(waf, pattern, collection) end,
	STR_CONTAINS = function(waf, collection, pattern) return _M.str_find(waf, collection, pattern) end,
	-- AC 自动机匹配
	PM           = function(waf, collection, pattern, ctx) return _M.ac_lookup(collection, pattern, ctx) end,
	CIDR_MATCH   = function(waf, collection, pattern) return _M.cidr_match(collection, pattern) end,
	RBL_LOOKUP   = function(waf, collection, pattern, ctx) return _M.rbl_lookup(waf, collection, pattern, ctx) end,
	DETECT_SQLI  = function(waf, collection, pattern) return _M.detect_sqli(collection) end,
	DETECT_XSS   = function(waf, collection, pattern) return _M.detect_xss(collection) end,
	STR_MATCH    = function(waf, collection, pattern) return _M.str_match(collection, pattern) end,
	VERIFY_CC    = function(waf, collection, pattern) return _M.verify_cc(waf, collection, pattern) end,
}
</code></pre>
<h3 id=16-执行动作>1.6. 执行动作</h3>
<h4 id=161-非数据操作类型>1.6.1. 非数据操作类型</h4>
<p>规则引擎的操作通常有 <em>允许、阻止、忽略、记录</em>。</p>
<blockquote>
<p>Cloudflare 有额外的执行动作：质询，我们经常可见的 CF 五秒盾后的验证码就是该动作。</p>
</blockquote>
<pre><code class=language-lua>-- 数据操作类型, 区别于 ACCEPT, CHAIN, IGNORE
_M.alter_actions = {
	DENY   = true,
	DROP   = true,
}

_M.disruptive_lookup = {
	ACCEPT = function(waf, ctx)
		--_LOG_&quot;Rule action was ACCEPT, so ending this phase with ngx.OK&quot;
		if waf._mode == &quot;ACTIVE&quot; then
			-- TODO 允许操作仍然返回后端状态码
			ngx.exit(ngx.OK)
		end
	end,
	CHAIN = function(waf, ctx)
		--_LOG_&quot;Chaining (pre-processed)&quot;
	end,
	DENY = function(waf, ctx)
		--_LOG_&quot;Rule action was DENY, so telling nginx to quit&quot;
		if waf._mode == &quot;ACTIVE&quot; then
			ngx.exit(ctx.rule_status or waf._deny_status)
		end
	end,
	DROP = function(waf, ctx)
		--_LOG_&quot;Rule action was DROP, ending eith ngx.HTTP_CLOSE&quot;
		if waf._mode == &quot;ACTIVE&quot; then
			ngx.exit(ngx.HTTP_CLOSE)
		end
	end,
	IGNORE = function(waf)
		--_LOG_&quot;Ignoring rule for now&quot;
	end,
	-- SCORE 类型废弃，使用 TX 设置危险分数
	SCORE = function(waf, ctx)
		--_LOG_&quot;Score isn't a thing anymore, see TX.anomaly_score&quot;
	end,
}
</code></pre>
<h4 id=162-数据操作类型>1.6.2. 数据操作类型</h4>
<p>OWASP ModSecurity 规则中有变量的操作，例如 <code>set_var</code> 以及增加威胁分数的操作，都是属于数据操作类型。</p>
<pre><code class=language-lua>-- 额外操作类型
_M.nondisruptive_lookup = {
	deletevar = function(waf, data, ctx, collections)
		storage.delete_var(waf, ctx, data)
	end,
	expirevar = function(waf, data, ctx, collections)
		local time = util.parse_dynamic_value(waf, data.time, collections)

		storage.expire_var(waf, ctx, data, time)
	end,
	initcol = function(waf, data, ctx, collections)
		local col    = data.col
		local value  = data.value
		local parsed = util.parse_dynamic_value(waf, value, collections)

		--_LOG_&quot;Initializing &quot; .. col .. &quot; as &quot; .. parsed

		storage.initialize(waf, ctx.storage, parsed)
		ctx.col_lookup[col] = parsed
		collections[col]    = ctx.storage[parsed]
	end,
	setvar = function(waf, data, ctx, collections)
		data.key    = util.parse_dynamic_value(waf, data.key, collections)
		local value = util.parse_dynamic_value(waf, data.value, collections)

		storage.set_var(waf, ctx, data, value)
	end,
	...
}
</code></pre>
<p>数据操作类型通常会设置变量，lua-resty-waf 中支持在 Nginx 共享内存和 Redis 中设置全局变量，在规则计算中使用。</p>
<h3 id=17-待优化>1.7. 待优化</h3>
<p>规则引擎中有部分操作明显可以优化，此处包含：</p>
<ol>
<li>数据集构建，引擎只需要规则定义中包含的字段，除此以外的数据获取是无效的</li>
<li>IPDR 匹配，纯 Lua 比较相比 C 库 FFI 调用效率较为低效</li>
</ol>
</div>
<footer class=post-footer>
<div class=post-meta>
<time datetime=" 2021-11-06" itemprop=datePublished>Nov 6, 2021</time>
</div>
</footer>
</article>
<script src=https://cdn.jsdelivr.net/npm/tocbot/dist/tocbot.min.js></script>
<aside class=typeface-sans lang=zh-hans>
<nav class=toc></nav>
</aside>
<script>tocbot.init({tocSelector:'.toc',contentSelector:'article',headingSelector:'h1, h2, h3, h4, h5',hasInnerContainers:!0,collapseDepth:"3",positionFixedSelector:".toc",headingsOffset:10})</script>
</div><script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/prism.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/filter-highlight-all/prism-filter-highlight-all.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js></script>
<script>Prism.plugins.filterHighlightAll.add(function(a){return a.language!=="mermaid"})</script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.init({startOnLoad:!0},"pre code.language-mermaid",function(){const a=document.querySelectorAll('code.language-mermaid');for(const c of a){c.style.backgroundColor='initial';const b=c.parentNode;b.style.border='none',b.style.textAlign='center',window.darkmode&&!window.darkmode.isActivated()&&(b.style.backgroundColor='initial')}})</script>
</div>
</main><footer class=site-footer>
<div class=wrapper>
<div class=social-links>
<a class="social-link social-github" href=https://github.com/mayocream><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5C9.34 21.58 9.5 21.27 9.5 21 9.5 20.77 9.5 20.14 9.5 19.31 6.73 19.91 6.14 17.97 6.14 17.97c-.46-1.16-1.11-1.47-1.11-1.47C4.12 15.88 5.1 15.9 5.1 15.9 6.1 15.97 6.63 16.93 6.63 16.93 7.5 18.45 8.97 18 9.54 17.76 9.63 17.11 9.89 16.67 10.17 16.42c-2.22-.25-4.55-1.11-4.55-4.92.0-1.11.38-2 1.03-2.71C6.55 8.54 6.2 7.5 6.75 6.15c0 0 .84-.27 2.75 1.02C10.29 6.95 11.15 6.84 12 6.84s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02C17.8 7.5 17.45 8.54 17.35 8.79 18 9.5 18.38 10.39 18.38 11.5c0 3.82-2.34 4.66-4.57 4.91C14.17 16.72 14.5 17.33 14.5 18.26c0 1.34.0 2.42.0 2.74.0.27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg>
</a>
<a class="social-link social-rss" href=/index.xml target=_blank><svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentcolor" d="M6.18 15.64a2.18 2.18.0 012.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18.0 012.18-2.18M4 4.44A15.56 15.56.0 0119.56 20H16.73A12.73 12.73.0 004 7.27V4.44M4 10.1A9.9 9.9.0 0113.9 20H11.07A7.07 7.07.0 004 12.93V10.1z"/></svg>
</a>
</div>
<div class=credits>
Theme KAGAMI by Kamikat
</div>
</div>
</footer><script>(function(a){for(var a=Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')),b=0,c;b!=a.length;b++)c=a[b],c.innerHTML=c.innerHTML.replace(/[\u2000-\u206e⸀-\u2e7e⺀-\u2efe⼀-\u2fde⿰-\u2ffe\u3000-〾\u3040-ゞ゠-ヾ\u3100-\u312e\u3130-ㆎ㆐-㆞ㆠ-\u31be㇀-\u31eeㇰ-ㇾ㈀-㋾㌀-㏾㐀-\u4dbe一-\u9ffe\ua960-\ua97e가-\ud7ae\ud7b0-\ud7fe豈-\ufafe︰-﹎\uff00-￮]|[\ud840-\ud868\ud86a-\ud86c][\udc00-\udfff]|\ud82c[\udc00-\udcfe]|\ud869[\udc00-\udede\udf00-\udfff]|\ud86d[\udc00-\udf3e\udf40-\udfff]|\ud86e[\udc00-\udc1e]|\ud87e[\udc00-\ude1e]/g,function(a){return'<span class="baseline-fix-block">'+a+'<'+'/span>'}),c.classList.remove('baseline-fix')})(Array.prototype.slice.call(document.getElementsByClassName('baseline-fix')))</script>
<script type=text/javascript>const resize=function(){this.width=.5*(this.naturalWidth||this.width)};Array.prototype.forEach.call(document.querySelectorAll('.half-size, .retina2x'),function(a){a.naturalWidth?resize.call(a):a.onload=resize})</script>
<script src=https://cdn.jsdelivr.net/npm/twemoji@13.1.0/dist/twemoji.min.js></script>
<script>twemoji.parse(document.body,{folder:'svg',ext:'.svg'})</script>
</body>